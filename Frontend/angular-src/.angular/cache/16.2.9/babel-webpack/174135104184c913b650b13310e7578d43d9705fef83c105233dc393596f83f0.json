{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function (d, b) {\n  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n  function __() {\n    this.constructor = d;\n  }\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n    d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata = this && this.__metadata || function (k, v) {\n  if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\nvar __param = this && this.__param || function (paramIndex, decorator) {\n  return function (target, key) {\n    decorator(target, key, paramIndex);\n  };\n};\nvar http_1 = require(\"@angular/http\");\nvar core_1 = require(\"@angular/core\");\nvar Observable_1 = require(\"rxjs/Observable\");\nrequire(\"rxjs/add/observable/fromPromise\");\nrequire(\"rxjs/add/observable/defer\");\nrequire(\"rxjs/add/operator/mergeMap\");\nvar AuthConfigConsts = function () {\n  function AuthConfigConsts() {}\n  return AuthConfigConsts;\n}();\nAuthConfigConsts.DEFAULT_TOKEN_NAME = 'token';\nAuthConfigConsts.DEFAULT_HEADER_NAME = 'Authorization';\nAuthConfigConsts.HEADER_PREFIX_BEARER = 'Bearer ';\nexports.AuthConfigConsts = AuthConfigConsts;\nvar AuthConfigDefaults = {\n  headerName: AuthConfigConsts.DEFAULT_HEADER_NAME,\n  headerPrefix: null,\n  tokenName: AuthConfigConsts.DEFAULT_TOKEN_NAME,\n  tokenGetter: function () {\n    return localStorage.getItem(AuthConfigDefaults.tokenName);\n  },\n  noJwtError: false,\n  noClientCheck: false,\n  globalHeaders: [],\n  noTokenScheme: false\n};\n/**\n * Sets up the authentication configuration.\n */\nvar AuthConfig = function () {\n  function AuthConfig(config) {\n    config = config || {};\n    this._config = objectAssign({}, AuthConfigDefaults, config);\n    if (this._config.headerPrefix) {\n      this._config.headerPrefix += ' ';\n    } else if (this._config.noTokenScheme) {\n      this._config.headerPrefix = '';\n    } else {\n      this._config.headerPrefix = AuthConfigConsts.HEADER_PREFIX_BEARER;\n    }\n    if (config.tokenName && !config.tokenGetter) {\n      this._config.tokenGetter = function () {\n        return localStorage.getItem(config.tokenName);\n      };\n    }\n  }\n  AuthConfig.prototype.getConfig = function () {\n    return this._config;\n  };\n  return AuthConfig;\n}();\nexports.AuthConfig = AuthConfig;\nvar AuthHttpError = function (_super) {\n  __extends(AuthHttpError, _super);\n  function AuthHttpError() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  return AuthHttpError;\n}(Error);\nexports.AuthHttpError = AuthHttpError;\n/**\n * Allows for explicit authenticated HTTP requests.\n */\nvar AuthHttp = function () {\n  function AuthHttp(options, http, defOpts) {\n    var _this = this;\n    this.http = http;\n    this.defOpts = defOpts;\n    this.config = options.getConfig();\n    this.tokenStream = new Observable_1.Observable(function (obs) {\n      obs.next(_this.config.tokenGetter());\n    });\n  }\n  AuthHttp.prototype.mergeOptions = function (providedOpts, defaultOpts) {\n    var newOptions = defaultOpts || new http_1.RequestOptions();\n    if (this.config.globalHeaders) {\n      this.setGlobalHeaders(this.config.globalHeaders, providedOpts);\n    }\n    newOptions = newOptions.merge(new http_1.RequestOptions(providedOpts));\n    return newOptions;\n  };\n  AuthHttp.prototype.requestHelper = function (requestArgs, additionalOptions) {\n    var options = new http_1.RequestOptions(requestArgs);\n    if (additionalOptions) {\n      options = options.merge(additionalOptions);\n    }\n    return this.request(new http_1.Request(this.mergeOptions(options, this.defOpts)));\n  };\n  AuthHttp.prototype.requestWithToken = function (req, token) {\n    if (!this.config.noClientCheck && !tokenNotExpired(undefined, token)) {\n      if (!this.config.noJwtError) {\n        return new Observable_1.Observable(function (obs) {\n          obs.error(new AuthHttpError('No JWT present or has expired'));\n        });\n      }\n    } else {\n      req.headers.set(this.config.headerName, this.config.headerPrefix + token);\n    }\n    return this.http.request(req);\n  };\n  AuthHttp.prototype.setGlobalHeaders = function (headers, request) {\n    if (!request.headers) {\n      request.headers = new http_1.Headers();\n    }\n    headers.forEach(function (header) {\n      var key = Object.keys(header)[0];\n      var headerValue = header[key];\n      request.headers.set(key, headerValue);\n    });\n  };\n  AuthHttp.prototype.request = function (url, options) {\n    var _this = this;\n    if (typeof url === 'string') {\n      return this.get(url, options); // Recursion: transform url from String to Request\n    }\n    // else if ( ! url instanceof Request ) {\n    //   throw new Error('First argument must be a url string or Request instance.');\n    // }\n    // from this point url is always an instance of Request;\n    var req = url;\n    // Create a cold observable and load the token just in time\n    return Observable_1.Observable.defer(function () {\n      var token = _this.config.tokenGetter();\n      if (token instanceof Promise) {\n        return Observable_1.Observable.fromPromise(token).mergeMap(function (jwtToken) {\n          return _this.requestWithToken(req, jwtToken);\n        });\n      } else {\n        return _this.requestWithToken(req, token);\n      }\n    });\n  };\n  AuthHttp.prototype.get = function (url, options) {\n    return this.requestHelper({\n      body: '',\n      method: http_1.RequestMethod.Get,\n      url: url\n    }, options);\n  };\n  AuthHttp.prototype.post = function (url, body, options) {\n    return this.requestHelper({\n      body: body,\n      method: http_1.RequestMethod.Post,\n      url: url\n    }, options);\n  };\n  AuthHttp.prototype.put = function (url, body, options) {\n    return this.requestHelper({\n      body: body,\n      method: http_1.RequestMethod.Put,\n      url: url\n    }, options);\n  };\n  AuthHttp.prototype.delete = function (url, options) {\n    return this.requestHelper({\n      body: '',\n      method: http_1.RequestMethod.Delete,\n      url: url\n    }, options);\n  };\n  AuthHttp.prototype.patch = function (url, body, options) {\n    return this.requestHelper({\n      body: body,\n      method: http_1.RequestMethod.Patch,\n      url: url\n    }, options);\n  };\n  AuthHttp.prototype.head = function (url, options) {\n    return this.requestHelper({\n      body: '',\n      method: http_1.RequestMethod.Head,\n      url: url\n    }, options);\n  };\n  AuthHttp.prototype.options = function (url, options) {\n    return this.requestHelper({\n      body: '',\n      method: http_1.RequestMethod.Options,\n      url: url\n    }, options);\n  };\n  return AuthHttp;\n}();\nAuthHttp = __decorate([core_1.Injectable(), __metadata(\"design:paramtypes\", [AuthConfig, http_1.Http, http_1.RequestOptions])], AuthHttp);\nexports.AuthHttp = AuthHttp;\n/**\n * Helper class to decode and find JWT expiration.\n */\nvar JwtHelper = function () {\n  function JwtHelper() {}\n  JwtHelper.prototype.urlBase64Decode = function (str) {\n    var output = str.replace(/-/g, '+').replace(/_/g, '/');\n    switch (output.length % 4) {\n      case 0:\n        {\n          break;\n        }\n      case 2:\n        {\n          output += '==';\n          break;\n        }\n      case 3:\n        {\n          output += '=';\n          break;\n        }\n      default:\n        {\n          throw 'Illegal base64url string!';\n        }\n    }\n    return this.b64DecodeUnicode(output);\n  };\n  // credits for decoder goes to https://github.com/atk\n  JwtHelper.prototype.b64decode = function (str) {\n    var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\n    var output = '';\n    str = String(str).replace(/=+$/, '');\n    if (str.length % 4 == 1) {\n      throw new Error(\"'atob' failed: The string to be decoded is not correctly encoded.\");\n    }\n    for (\n    // initialize result and counters\n    var bc = 0, bs = void 0, buffer = void 0, idx = 0;\n    // get next character\n    buffer = str.charAt(idx++);\n    // character found in table? initialize bit storage and add its ascii value;\n    ~buffer && (bs = bc % 4 ? bs * 64 + buffer : buffer,\n    // and if not first of each 4 characters,\n    // convert the first 8 bits to one ascii character\n    bc++ % 4) ? output += String.fromCharCode(255 & bs >> (-2 * bc & 6)) : 0) {\n      // try to find character in table (0-63, not found => -1)\n      buffer = chars.indexOf(buffer);\n    }\n    return output;\n  };\n  // https://developer.mozilla.org/en/docs/Web/API/WindowBase64/Base64_encoding_and_decoding#The_Unicode_Problem\n  JwtHelper.prototype.b64DecodeUnicode = function (str) {\n    return decodeURIComponent(Array.prototype.map.call(this.b64decode(str), function (c) {\n      return '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2);\n    }).join(''));\n  };\n  JwtHelper.prototype.decodeToken = function (token) {\n    var parts = token.split('.');\n    if (parts.length !== 3) {\n      throw new Error('JWT must have 3 parts');\n    }\n    var decoded = this.urlBase64Decode(parts[1]);\n    if (!decoded) {\n      throw new Error('Cannot decode the token');\n    }\n    return JSON.parse(decoded);\n  };\n  JwtHelper.prototype.getTokenExpirationDate = function (token) {\n    var decoded;\n    decoded = this.decodeToken(token);\n    if (!decoded.hasOwnProperty('exp')) {\n      return null;\n    }\n    var date = new Date(0); // The 0 here is the key, which sets the date to the epoch\n    date.setUTCSeconds(decoded.exp);\n    return date;\n  };\n  JwtHelper.prototype.isTokenExpired = function (token, offsetSeconds) {\n    var date = this.getTokenExpirationDate(token);\n    offsetSeconds = offsetSeconds || 0;\n    if (date == null) {\n      return false;\n    }\n    // Token expired?\n    return !(date.valueOf() > new Date().valueOf() + offsetSeconds * 1000);\n  };\n  return JwtHelper;\n}();\nexports.JwtHelper = JwtHelper;\n/**\n * Checks for presence of token and that token hasn't expired.\n * For use with the @CanActivate router decorator and NgIf\n */\nfunction tokenNotExpired(tokenName, jwt) {\n  if (tokenName === void 0) {\n    tokenName = AuthConfigConsts.DEFAULT_TOKEN_NAME;\n  }\n  var token = jwt || localStorage.getItem(tokenName);\n  var jwtHelper = new JwtHelper();\n  return token != null && !jwtHelper.isTokenExpired(token);\n}\nexports.tokenNotExpired = tokenNotExpired;\nexports.AUTH_PROVIDERS = [{\n  provide: AuthHttp,\n  deps: [http_1.Http, http_1.RequestOptions],\n  useFactory: function (http, options) {\n    return new AuthHttp(new AuthConfig(), http, options);\n  }\n}];\nfunction provideAuth(config) {\n  return [{\n    provide: AuthHttp,\n    deps: [http_1.Http, http_1.RequestOptions],\n    useFactory: function (http, options) {\n      return new AuthHttp(new AuthConfig(config), http, options);\n    }\n  }];\n}\nexports.provideAuth = provideAuth;\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nvar propIsEnumerable = Object.prototype.propertyIsEnumerable;\nfunction toObject(val) {\n  if (val === null || val === undefined) {\n    throw new TypeError('Object.assign cannot be called with null or undefined');\n  }\n  return Object(val);\n}\nfunction objectAssign(target) {\n  var source = [];\n  for (var _i = 1; _i < arguments.length; _i++) {\n    source[_i - 1] = arguments[_i];\n  }\n  var from;\n  var to = toObject(target);\n  var symbols;\n  for (var s = 1; s < arguments.length; s++) {\n    from = Object(arguments[s]);\n    for (var key in from) {\n      if (hasOwnProperty.call(from, key)) {\n        to[key] = from[key];\n      }\n    }\n    if (Object.getOwnPropertySymbols) {\n      symbols = Object.getOwnPropertySymbols(from);\n      for (var i = 0; i < symbols.length; i++) {\n        if (propIsEnumerable.call(from, symbols[i])) {\n          to[symbols[i]] = from[symbols[i]];\n        }\n      }\n    }\n  }\n  return to;\n}\n/**\n * Module for angular2-jwt\n * @experimental\n */\nvar AuthModule = AuthModule_1 = function () {\n  function AuthModule(parentModule) {\n    if (parentModule) {\n      throw new Error('AuthModule is already loaded. Import it in the AppModule only');\n    }\n  }\n  AuthModule.forRoot = function (config) {\n    return {\n      ngModule: AuthModule_1,\n      providers: [{\n        provide: AuthConfig,\n        useValue: config\n      }]\n    };\n  };\n  return AuthModule;\n}();\nAuthModule = AuthModule_1 = __decorate([core_1.NgModule({\n  imports: [http_1.HttpModule],\n  providers: [AuthHttp, JwtHelper]\n}), __param(0, core_1.Optional()), __param(0, core_1.SkipSelf()), __metadata(\"design:paramtypes\", [AuthModule])], AuthModule);\nexports.AuthModule = AuthModule;\nvar AuthModule_1;\n//# sourceMappingURL=angular2-jwt.js.map","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}