{"ast":null,"code":"/**\n * @license Angular v4.4.7\n * (c) 2010-2017 Google, Inc. https://angular.io/\n * License: MIT\n */\nimport { CommonModule, DOCUMENT, PlatformLocation, ɵPLATFORM_BROWSER_ID, ɵparseCookieValue } from '@angular/common';\nimport { APP_ID, APP_INITIALIZER, ApplicationInitStatus, ApplicationModule, ApplicationRef, ErrorHandler, Inject, Injectable, InjectionToken, Injector, NgModule, NgProbeToken, NgZone, Optional, PLATFORM_ID, PLATFORM_INITIALIZER, RendererFactory2, RendererStyleFlags2, Sanitizer, SecurityContext, SkipSelf, Testability, Version, ViewEncapsulation, createPlatformFactory, getDebugNode, isDevMode, platformCore, setTestabilityGetter, ɵglobal } from '@angular/core';\nimport * as core from '@angular/core';\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nlet _DOM = null;\n/**\n * @return {?}\n */\nfunction getDOM() {\n  return _DOM;\n}\n/**\n * @param {?} adapter\n * @return {?}\n */\n\n/**\n * @param {?} adapter\n * @return {?}\n */\nfunction setRootDomAdapter(adapter) {\n  if (!_DOM) {\n    _DOM = adapter;\n  }\n}\n/**\n * Provides DOM operations in an environment-agnostic way.\n *\n * \\@security Tread carefully! Interacting with the DOM directly is dangerous and\n * can introduce XSS risks.\n * @abstract\n */\nclass DomAdapter {\n  constructor() {\n    this.resourceLoaderType = null;\n  }\n  /**\n   * @abstract\n   * @param {?} element\n   * @param {?} name\n   * @return {?}\n   */\n  hasProperty(element, name) {}\n  /**\n   * @abstract\n   * @param {?} el\n   * @param {?} name\n   * @param {?} value\n   * @return {?}\n   */\n  setProperty(el, name, value) {}\n  /**\n   * @abstract\n   * @param {?} el\n   * @param {?} name\n   * @return {?}\n   */\n  getProperty(el, name) {}\n  /**\n   * @abstract\n   * @param {?} el\n   * @param {?} methodName\n   * @param {?} args\n   * @return {?}\n   */\n  invoke(el, methodName, args) {}\n  /**\n   * @abstract\n   * @param {?} error\n   * @return {?}\n   */\n  logError(error) {}\n  /**\n   * @abstract\n   * @param {?} error\n   * @return {?}\n   */\n  log(error) {}\n  /**\n   * @abstract\n   * @param {?} error\n   * @return {?}\n   */\n  logGroup(error) {}\n  /**\n   * @abstract\n   * @return {?}\n   */\n  logGroupEnd() {}\n  /**\n   * Maps attribute names to their corresponding property names for cases\n   * where attribute name doesn't match property name.\n   * @return {?}\n   */\n  get attrToPropMap() {\n    return this._attrToPropMap;\n  }\n  /**\n   * @param {?} value\n   * @return {?}\n   */\n  set attrToPropMap(value) {\n    this._attrToPropMap = value;\n  }\n  /**\n   * @abstract\n   * @param {?} nodeA\n   * @param {?} nodeB\n   * @return {?}\n   */\n  contains(nodeA, nodeB) {}\n  /**\n   * @abstract\n   * @param {?} templateHtml\n   * @return {?}\n   */\n  parse(templateHtml) {}\n  /**\n   * @abstract\n   * @param {?} el\n   * @param {?} selector\n   * @return {?}\n   */\n  querySelector(el, selector) {}\n  /**\n   * @abstract\n   * @param {?} el\n   * @param {?} selector\n   * @return {?}\n   */\n  querySelectorAll(el, selector) {}\n  /**\n   * @abstract\n   * @param {?} el\n   * @param {?} evt\n   * @param {?} listener\n   * @return {?}\n   */\n  on(el, evt, listener) {}\n  /**\n   * @abstract\n   * @param {?} el\n   * @param {?} evt\n   * @param {?} listener\n   * @return {?}\n   */\n  onAndCancel(el, evt, listener) {}\n  /**\n   * @abstract\n   * @param {?} el\n   * @param {?} evt\n   * @return {?}\n   */\n  dispatchEvent(el, evt) {}\n  /**\n   * @abstract\n   * @param {?} eventType\n   * @return {?}\n   */\n  createMouseEvent(eventType) {}\n  /**\n   * @abstract\n   * @param {?} eventType\n   * @return {?}\n   */\n  createEvent(eventType) {}\n  /**\n   * @abstract\n   * @param {?} evt\n   * @return {?}\n   */\n  preventDefault(evt) {}\n  /**\n   * @abstract\n   * @param {?} evt\n   * @return {?}\n   */\n  isPrevented(evt) {}\n  /**\n   * @abstract\n   * @param {?} el\n   * @return {?}\n   */\n  getInnerHTML(el) {}\n  /**\n   * Returns content if el is a <template> element, null otherwise.\n   * @abstract\n   * @param {?} el\n   * @return {?}\n   */\n  getTemplateContent(el) {}\n  /**\n   * @abstract\n   * @param {?} el\n   * @return {?}\n   */\n  getOuterHTML(el) {}\n  /**\n   * @abstract\n   * @param {?} node\n   * @return {?}\n   */\n  nodeName(node) {}\n  /**\n   * @abstract\n   * @param {?} node\n   * @return {?}\n   */\n  nodeValue(node) {}\n  /**\n   * @abstract\n   * @param {?} node\n   * @return {?}\n   */\n  type(node) {}\n  /**\n   * @abstract\n   * @param {?} node\n   * @return {?}\n   */\n  content(node) {}\n  /**\n   * @abstract\n   * @param {?} el\n   * @return {?}\n   */\n  firstChild(el) {}\n  /**\n   * @abstract\n   * @param {?} el\n   * @return {?}\n   */\n  nextSibling(el) {}\n  /**\n   * @abstract\n   * @param {?} el\n   * @return {?}\n   */\n  parentElement(el) {}\n  /**\n   * @abstract\n   * @param {?} el\n   * @return {?}\n   */\n  childNodes(el) {}\n  /**\n   * @abstract\n   * @param {?} el\n   * @return {?}\n   */\n  childNodesAsList(el) {}\n  /**\n   * @abstract\n   * @param {?} el\n   * @return {?}\n   */\n  clearNodes(el) {}\n  /**\n   * @abstract\n   * @param {?} el\n   * @param {?} node\n   * @return {?}\n   */\n  appendChild(el, node) {}\n  /**\n   * @abstract\n   * @param {?} el\n   * @param {?} node\n   * @return {?}\n   */\n  removeChild(el, node) {}\n  /**\n   * @abstract\n   * @param {?} el\n   * @param {?} newNode\n   * @param {?} oldNode\n   * @return {?}\n   */\n  replaceChild(el, newNode, oldNode) {}\n  /**\n   * @abstract\n   * @param {?} el\n   * @return {?}\n   */\n  remove(el) {}\n  /**\n   * @abstract\n   * @param {?} parent\n   * @param {?} ref\n   * @param {?} node\n   * @return {?}\n   */\n  insertBefore(parent, ref, node) {}\n  /**\n   * @abstract\n   * @param {?} parent\n   * @param {?} ref\n   * @param {?} nodes\n   * @return {?}\n   */\n  insertAllBefore(parent, ref, nodes) {}\n  /**\n   * @abstract\n   * @param {?} parent\n   * @param {?} el\n   * @param {?} node\n   * @return {?}\n   */\n  insertAfter(parent, el, node) {}\n  /**\n   * @abstract\n   * @param {?} el\n   * @param {?} value\n   * @return {?}\n   */\n  setInnerHTML(el, value) {}\n  /**\n   * @abstract\n   * @param {?} el\n   * @return {?}\n   */\n  getText(el) {}\n  /**\n   * @abstract\n   * @param {?} el\n   * @param {?} value\n   * @return {?}\n   */\n  setText(el, value) {}\n  /**\n   * @abstract\n   * @param {?} el\n   * @return {?}\n   */\n  getValue(el) {}\n  /**\n   * @abstract\n   * @param {?} el\n   * @param {?} value\n   * @return {?}\n   */\n  setValue(el, value) {}\n  /**\n   * @abstract\n   * @param {?} el\n   * @return {?}\n   */\n  getChecked(el) {}\n  /**\n   * @abstract\n   * @param {?} el\n   * @param {?} value\n   * @return {?}\n   */\n  setChecked(el, value) {}\n  /**\n   * @abstract\n   * @param {?} text\n   * @return {?}\n   */\n  createComment(text) {}\n  /**\n   * @abstract\n   * @param {?} html\n   * @return {?}\n   */\n  createTemplate(html) {}\n  /**\n   * @abstract\n   * @param {?} tagName\n   * @param {?=} doc\n   * @return {?}\n   */\n  createElement(tagName, doc) {}\n  /**\n   * @abstract\n   * @param {?} ns\n   * @param {?} tagName\n   * @param {?=} doc\n   * @return {?}\n   */\n  createElementNS(ns, tagName, doc) {}\n  /**\n   * @abstract\n   * @param {?} text\n   * @param {?=} doc\n   * @return {?}\n   */\n  createTextNode(text, doc) {}\n  /**\n   * @abstract\n   * @param {?} attrName\n   * @param {?} attrValue\n   * @param {?=} doc\n   * @return {?}\n   */\n  createScriptTag(attrName, attrValue, doc) {}\n  /**\n   * @abstract\n   * @param {?} css\n   * @param {?=} doc\n   * @return {?}\n   */\n  createStyleElement(css, doc) {}\n  /**\n   * @abstract\n   * @param {?} el\n   * @return {?}\n   */\n  createShadowRoot(el) {}\n  /**\n   * @abstract\n   * @param {?} el\n   * @return {?}\n   */\n  getShadowRoot(el) {}\n  /**\n   * @abstract\n   * @param {?} el\n   * @return {?}\n   */\n  getHost(el) {}\n  /**\n   * @abstract\n   * @param {?} el\n   * @return {?}\n   */\n  getDistributedNodes(el) {}\n  /**\n   * @abstract\n   * @param {?} node\n   * @return {?}\n   */\n  clone /*<T extends Node>*/(node) {}\n  /**\n   * @abstract\n   * @param {?} element\n   * @param {?} name\n   * @return {?}\n   */\n  getElementsByClassName(element, name) {}\n  /**\n   * @abstract\n   * @param {?} element\n   * @param {?} name\n   * @return {?}\n   */\n  getElementsByTagName(element, name) {}\n  /**\n   * @abstract\n   * @param {?} element\n   * @return {?}\n   */\n  classList(element) {}\n  /**\n   * @abstract\n   * @param {?} element\n   * @param {?} className\n   * @return {?}\n   */\n  addClass(element, className) {}\n  /**\n   * @abstract\n   * @param {?} element\n   * @param {?} className\n   * @return {?}\n   */\n  removeClass(element, className) {}\n  /**\n   * @abstract\n   * @param {?} element\n   * @param {?} className\n   * @return {?}\n   */\n  hasClass(element, className) {}\n  /**\n   * @abstract\n   * @param {?} element\n   * @param {?} styleName\n   * @param {?} styleValue\n   * @return {?}\n   */\n  setStyle(element, styleName, styleValue) {}\n  /**\n   * @abstract\n   * @param {?} element\n   * @param {?} styleName\n   * @return {?}\n   */\n  removeStyle(element, styleName) {}\n  /**\n   * @abstract\n   * @param {?} element\n   * @param {?} styleName\n   * @return {?}\n   */\n  getStyle(element, styleName) {}\n  /**\n   * @abstract\n   * @param {?} element\n   * @param {?} styleName\n   * @param {?=} styleValue\n   * @return {?}\n   */\n  hasStyle(element, styleName, styleValue) {}\n  /**\n   * @abstract\n   * @param {?} element\n   * @return {?}\n   */\n  tagName(element) {}\n  /**\n   * @abstract\n   * @param {?} element\n   * @return {?}\n   */\n  attributeMap(element) {}\n  /**\n   * @abstract\n   * @param {?} element\n   * @param {?} attribute\n   * @return {?}\n   */\n  hasAttribute(element, attribute) {}\n  /**\n   * @abstract\n   * @param {?} element\n   * @param {?} ns\n   * @param {?} attribute\n   * @return {?}\n   */\n  hasAttributeNS(element, ns, attribute) {}\n  /**\n   * @abstract\n   * @param {?} element\n   * @param {?} attribute\n   * @return {?}\n   */\n  getAttribute(element, attribute) {}\n  /**\n   * @abstract\n   * @param {?} element\n   * @param {?} ns\n   * @param {?} attribute\n   * @return {?}\n   */\n  getAttributeNS(element, ns, attribute) {}\n  /**\n   * @abstract\n   * @param {?} element\n   * @param {?} name\n   * @param {?} value\n   * @return {?}\n   */\n  setAttribute(element, name, value) {}\n  /**\n   * @abstract\n   * @param {?} element\n   * @param {?} ns\n   * @param {?} name\n   * @param {?} value\n   * @return {?}\n   */\n  setAttributeNS(element, ns, name, value) {}\n  /**\n   * @abstract\n   * @param {?} element\n   * @param {?} attribute\n   * @return {?}\n   */\n  removeAttribute(element, attribute) {}\n  /**\n   * @abstract\n   * @param {?} element\n   * @param {?} ns\n   * @param {?} attribute\n   * @return {?}\n   */\n  removeAttributeNS(element, ns, attribute) {}\n  /**\n   * @abstract\n   * @param {?} el\n   * @return {?}\n   */\n  templateAwareRoot(el) {}\n  /**\n   * @abstract\n   * @return {?}\n   */\n  createHtmlDocument() {}\n  /**\n   * @abstract\n   * @param {?} el\n   * @return {?}\n   */\n  getBoundingClientRect(el) {}\n  /**\n   * @abstract\n   * @param {?} doc\n   * @return {?}\n   */\n  getTitle(doc) {}\n  /**\n   * @abstract\n   * @param {?} doc\n   * @param {?} newTitle\n   * @return {?}\n   */\n  setTitle(doc, newTitle) {}\n  /**\n   * @abstract\n   * @param {?} n\n   * @param {?} selector\n   * @return {?}\n   */\n  elementMatches(n, selector) {}\n  /**\n   * @abstract\n   * @param {?} el\n   * @return {?}\n   */\n  isTemplateElement(el) {}\n  /**\n   * @abstract\n   * @param {?} node\n   * @return {?}\n   */\n  isTextNode(node) {}\n  /**\n   * @abstract\n   * @param {?} node\n   * @return {?}\n   */\n  isCommentNode(node) {}\n  /**\n   * @abstract\n   * @param {?} node\n   * @return {?}\n   */\n  isElementNode(node) {}\n  /**\n   * @abstract\n   * @param {?} node\n   * @return {?}\n   */\n  hasShadowRoot(node) {}\n  /**\n   * @abstract\n   * @param {?} node\n   * @return {?}\n   */\n  isShadowRoot(node) {}\n  /**\n   * @abstract\n   * @param {?} node\n   * @return {?}\n   */\n  importIntoDoc /*<T extends Node>*/(node) {}\n  /**\n   * @abstract\n   * @param {?} node\n   * @return {?}\n   */\n  adoptNode /*<T extends Node>*/(node) {}\n  /**\n   * @abstract\n   * @param {?} element\n   * @return {?}\n   */\n  getHref(element) {}\n  /**\n   * @abstract\n   * @param {?} event\n   * @return {?}\n   */\n  getEventKey(event) {}\n  /**\n   * @abstract\n   * @param {?} element\n   * @param {?} baseUrl\n   * @param {?} href\n   * @return {?}\n   */\n  resolveAndSetHref(element, baseUrl, href) {}\n  /**\n   * @abstract\n   * @return {?}\n   */\n  supportsDOMEvents() {}\n  /**\n   * @abstract\n   * @return {?}\n   */\n  supportsNativeShadowDOM() {}\n  /**\n   * @abstract\n   * @param {?} doc\n   * @param {?} target\n   * @return {?}\n   */\n  getGlobalEventTarget(doc, target) {}\n  /**\n   * @abstract\n   * @return {?}\n   */\n  getHistory() {}\n  /**\n   * @abstract\n   * @return {?}\n   */\n  getLocation() {}\n  /**\n   * @abstract\n   * @param {?} doc\n   * @return {?}\n   */\n  getBaseHref(doc) {}\n  /**\n   * @abstract\n   * @return {?}\n   */\n  resetBaseElement() {}\n  /**\n   * @abstract\n   * @return {?}\n   */\n  getUserAgent() {}\n  /**\n   * @abstract\n   * @param {?} element\n   * @param {?} name\n   * @param {?} value\n   * @return {?}\n   */\n  setData(element, name, value) {}\n  /**\n   * @abstract\n   * @param {?} element\n   * @return {?}\n   */\n  getComputedStyle(element) {}\n  /**\n   * @abstract\n   * @param {?} element\n   * @param {?} name\n   * @return {?}\n   */\n  getData(element, name) {}\n  /**\n   * @abstract\n   * @return {?}\n   */\n  supportsWebAnimation() {}\n  /**\n   * @abstract\n   * @return {?}\n   */\n  performanceNow() {}\n  /**\n   * @abstract\n   * @return {?}\n   */\n  getAnimationPrefix() {}\n  /**\n   * @abstract\n   * @return {?}\n   */\n  getTransitionEnd() {}\n  /**\n   * @abstract\n   * @return {?}\n   */\n  supportsAnimation() {}\n  /**\n   * @abstract\n   * @return {?}\n   */\n  supportsCookies() {}\n  /**\n   * @abstract\n   * @param {?} name\n   * @return {?}\n   */\n  getCookie(name) {}\n  /**\n   * @abstract\n   * @param {?} name\n   * @param {?} value\n   * @return {?}\n   */\n  setCookie(name, value) {}\n}\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Provides DOM operations in any browser environment.\n *\n * \\@security Tread carefully! Interacting with the DOM directly is dangerous and\n * can introduce XSS risks.\n * @abstract\n */\nclass GenericBrowserDomAdapter extends DomAdapter {\n  constructor() {\n    super();\n    this._animationPrefix = null;\n    this._transitionEnd = null;\n    try {\n      const element = this.createElement('div', document);\n      if (this.getStyle(element, 'animationName') != null) {\n        this._animationPrefix = '';\n      } else {\n        const domPrefixes = ['Webkit', 'Moz', 'O', 'ms'];\n        for (let i = 0; i < domPrefixes.length; i++) {\n          if (this.getStyle(element, domPrefixes[i] + 'AnimationName') != null) {\n            this._animationPrefix = '-' + domPrefixes[i].toLowerCase() + '-';\n            break;\n          }\n        }\n      }\n      const transEndEventNames = {\n        WebkitTransition: 'webkitTransitionEnd',\n        MozTransition: 'transitionend',\n        OTransition: 'oTransitionEnd otransitionend',\n        transition: 'transitionend'\n      };\n      Object.keys(transEndEventNames).forEach(key => {\n        if (this.getStyle(element, key) != null) {\n          this._transitionEnd = transEndEventNames[key];\n        }\n      });\n    } catch (e) {\n      this._animationPrefix = null;\n      this._transitionEnd = null;\n    }\n  }\n  /**\n   * @param {?} el\n   * @return {?}\n   */\n  getDistributedNodes(el) {\n    return el.getDistributedNodes();\n  }\n  /**\n   * @param {?} el\n   * @param {?} baseUrl\n   * @param {?} href\n   * @return {?}\n   */\n  resolveAndSetHref(el, baseUrl, href) {\n    el.href = href == null ? baseUrl : baseUrl + '/../' + href;\n  }\n  /**\n   * @return {?}\n   */\n  supportsDOMEvents() {\n    return true;\n  }\n  /**\n   * @return {?}\n   */\n  supportsNativeShadowDOM() {\n    return typeof document.body.createShadowRoot === 'function';\n  }\n  /**\n   * @return {?}\n   */\n  getAnimationPrefix() {\n    return this._animationPrefix ? this._animationPrefix : '';\n  }\n  /**\n   * @return {?}\n   */\n  getTransitionEnd() {\n    return this._transitionEnd ? this._transitionEnd : '';\n  }\n  /**\n   * @return {?}\n   */\n  supportsAnimation() {\n    return this._animationPrefix != null && this._transitionEnd != null;\n  }\n}\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nconst _attrToPropMap = {\n  'class': 'className',\n  'innerHtml': 'innerHTML',\n  'readonly': 'readOnly',\n  'tabindex': 'tabIndex'\n};\nconst DOM_KEY_LOCATION_NUMPAD = 3;\n// Map to convert some key or keyIdentifier values to what will be returned by getEventKey\nconst _keyMap = {\n  // The following values are here for cross-browser compatibility and to match the W3C standard\n  // cf http://www.w3.org/TR/DOM-Level-3-Events-key/\n  '\\b': 'Backspace',\n  '\\t': 'Tab',\n  '\\x7F': 'Delete',\n  '\\x1B': 'Escape',\n  'Del': 'Delete',\n  'Esc': 'Escape',\n  'Left': 'ArrowLeft',\n  'Right': 'ArrowRight',\n  'Up': 'ArrowUp',\n  'Down': 'ArrowDown',\n  'Menu': 'ContextMenu',\n  'Scroll': 'ScrollLock',\n  'Win': 'OS'\n};\n// There is a bug in Chrome for numeric keypad keys:\n// https://code.google.com/p/chromium/issues/detail?id=155654\n// 1, 2, 3 ... are reported as A, B, C ...\nconst _chromeNumKeyPadMap = {\n  'A': '1',\n  'B': '2',\n  'C': '3',\n  'D': '4',\n  'E': '5',\n  'F': '6',\n  'G': '7',\n  'H': '8',\n  'I': '9',\n  'J': '*',\n  'K': '+',\n  'M': '-',\n  'N': '.',\n  'O': '/',\n  '\\x60': '0',\n  '\\x90': 'NumLock'\n};\nlet nodeContains;\nif (ɵglobal['Node']) {\n  nodeContains = ɵglobal['Node'].prototype.contains || function (node) {\n    return !!(this.compareDocumentPosition(node) & 16);\n  };\n}\nclass BrowserDomAdapter extends GenericBrowserDomAdapter {\n  /**\n   * @param {?} templateHtml\n   * @return {?}\n   */\n  parse(templateHtml) {\n    throw new Error('parse not implemented');\n  }\n  /**\n   * @return {?}\n   */\n  static makeCurrent() {\n    setRootDomAdapter(new BrowserDomAdapter());\n  }\n  /**\n   * @param {?} element\n   * @param {?} name\n   * @return {?}\n   */\n  hasProperty(element, name) {\n    return name in element;\n  }\n  /**\n   * @param {?} el\n   * @param {?} name\n   * @param {?} value\n   * @return {?}\n   */\n  setProperty(el, name, value) {\n    el[name] = value;\n  }\n  /**\n   * @param {?} el\n   * @param {?} name\n   * @return {?}\n   */\n  getProperty(el, name) {\n    return el[name];\n  }\n  /**\n   * @param {?} el\n   * @param {?} methodName\n   * @param {?} args\n   * @return {?}\n   */\n  invoke(el, methodName, args) {\n    el[methodName](...args);\n  }\n  /**\n   * @param {?} error\n   * @return {?}\n   */\n  logError(error) {\n    if (window.console) {\n      if (console.error) {\n        console.error(error);\n      } else {\n        console.log(error);\n      }\n    }\n  }\n  /**\n   * @param {?} error\n   * @return {?}\n   */\n  log(error) {\n    if (window.console) {\n      window.console.log && window.console.log(error);\n    }\n  }\n  /**\n   * @param {?} error\n   * @return {?}\n   */\n  logGroup(error) {\n    if (window.console) {\n      window.console.group && window.console.group(error);\n    }\n  }\n  /**\n   * @return {?}\n   */\n  logGroupEnd() {\n    if (window.console) {\n      window.console.groupEnd && window.console.groupEnd();\n    }\n  }\n  /**\n   * @return {?}\n   */\n  get attrToPropMap() {\n    return _attrToPropMap;\n  }\n  /**\n   * @param {?} nodeA\n   * @param {?} nodeB\n   * @return {?}\n   */\n  contains(nodeA, nodeB) {\n    return nodeContains.call(nodeA, nodeB);\n  }\n  /**\n   * @param {?} el\n   * @param {?} selector\n   * @return {?}\n   */\n  querySelector(el, selector) {\n    return el.querySelector(selector);\n  }\n  /**\n   * @param {?} el\n   * @param {?} selector\n   * @return {?}\n   */\n  querySelectorAll(el, selector) {\n    return el.querySelectorAll(selector);\n  }\n  /**\n   * @param {?} el\n   * @param {?} evt\n   * @param {?} listener\n   * @return {?}\n   */\n  on(el, evt, listener) {\n    el.addEventListener(evt, listener, false);\n  }\n  /**\n   * @param {?} el\n   * @param {?} evt\n   * @param {?} listener\n   * @return {?}\n   */\n  onAndCancel(el, evt, listener) {\n    el.addEventListener(evt, listener, false);\n    // Needed to follow Dart's subscription semantic, until fix of\n    // https://code.google.com/p/dart/issues/detail?id=17406\n    return () => {\n      el.removeEventListener(evt, listener, false);\n    };\n  }\n  /**\n   * @param {?} el\n   * @param {?} evt\n   * @return {?}\n   */\n  dispatchEvent(el, evt) {\n    el.dispatchEvent(evt);\n  }\n  /**\n   * @param {?} eventType\n   * @return {?}\n   */\n  createMouseEvent(eventType) {\n    const /** @type {?} */evt = document.createEvent('MouseEvent');\n    evt.initEvent(eventType, true, true);\n    return evt;\n  }\n  /**\n   * @param {?} eventType\n   * @return {?}\n   */\n  createEvent(eventType) {\n    const /** @type {?} */evt = document.createEvent('Event');\n    evt.initEvent(eventType, true, true);\n    return evt;\n  }\n  /**\n   * @param {?} evt\n   * @return {?}\n   */\n  preventDefault(evt) {\n    evt.preventDefault();\n    evt.returnValue = false;\n  }\n  /**\n   * @param {?} evt\n   * @return {?}\n   */\n  isPrevented(evt) {\n    return evt.defaultPrevented || evt.returnValue != null && !evt.returnValue;\n  }\n  /**\n   * @param {?} el\n   * @return {?}\n   */\n  getInnerHTML(el) {\n    return el.innerHTML;\n  }\n  /**\n   * @param {?} el\n   * @return {?}\n   */\n  getTemplateContent(el) {\n    return 'content' in el && el instanceof HTMLTemplateElement ? el.content : null;\n  }\n  /**\n   * @param {?} el\n   * @return {?}\n   */\n  getOuterHTML(el) {\n    return el.outerHTML;\n  }\n  /**\n   * @param {?} node\n   * @return {?}\n   */\n  nodeName(node) {\n    return node.nodeName;\n  }\n  /**\n   * @param {?} node\n   * @return {?}\n   */\n  nodeValue(node) {\n    return node.nodeValue;\n  }\n  /**\n   * @param {?} node\n   * @return {?}\n   */\n  type(node) {\n    return node.type;\n  }\n  /**\n   * @param {?} node\n   * @return {?}\n   */\n  content(node) {\n    if (this.hasProperty(node, 'content')) {\n      return node.content;\n    } else {\n      return node;\n    }\n  }\n  /**\n   * @param {?} el\n   * @return {?}\n   */\n  firstChild(el) {\n    return el.firstChild;\n  }\n  /**\n   * @param {?} el\n   * @return {?}\n   */\n  nextSibling(el) {\n    return el.nextSibling;\n  }\n  /**\n   * @param {?} el\n   * @return {?}\n   */\n  parentElement(el) {\n    return el.parentNode;\n  }\n  /**\n   * @param {?} el\n   * @return {?}\n   */\n  childNodes(el) {\n    return el.childNodes;\n  }\n  /**\n   * @param {?} el\n   * @return {?}\n   */\n  childNodesAsList(el) {\n    const /** @type {?} */childNodes = el.childNodes;\n    const /** @type {?} */res = new Array(childNodes.length);\n    for (let /** @type {?} */i = 0; i < childNodes.length; i++) {\n      res[i] = childNodes[i];\n    }\n    return res;\n  }\n  /**\n   * @param {?} el\n   * @return {?}\n   */\n  clearNodes(el) {\n    while (el.firstChild) {\n      el.removeChild(el.firstChild);\n    }\n  }\n  /**\n   * @param {?} el\n   * @param {?} node\n   * @return {?}\n   */\n  appendChild(el, node) {\n    el.appendChild(node);\n  }\n  /**\n   * @param {?} el\n   * @param {?} node\n   * @return {?}\n   */\n  removeChild(el, node) {\n    el.removeChild(node);\n  }\n  /**\n   * @param {?} el\n   * @param {?} newChild\n   * @param {?} oldChild\n   * @return {?}\n   */\n  replaceChild(el, newChild, oldChild) {\n    el.replaceChild(newChild, oldChild);\n  }\n  /**\n   * @param {?} node\n   * @return {?}\n   */\n  remove(node) {\n    if (node.parentNode) {\n      node.parentNode.removeChild(node);\n    }\n    return node;\n  }\n  /**\n   * @param {?} parent\n   * @param {?} ref\n   * @param {?} node\n   * @return {?}\n   */\n  insertBefore(parent, ref, node) {\n    parent.insertBefore(node, ref);\n  }\n  /**\n   * @param {?} parent\n   * @param {?} ref\n   * @param {?} nodes\n   * @return {?}\n   */\n  insertAllBefore(parent, ref, nodes) {\n    nodes.forEach(n => parent.insertBefore(n, ref));\n  }\n  /**\n   * @param {?} parent\n   * @param {?} ref\n   * @param {?} node\n   * @return {?}\n   */\n  insertAfter(parent, ref, node) {\n    parent.insertBefore(node, ref.nextSibling);\n  }\n  /**\n   * @param {?} el\n   * @param {?} value\n   * @return {?}\n   */\n  setInnerHTML(el, value) {\n    el.innerHTML = value;\n  }\n  /**\n   * @param {?} el\n   * @return {?}\n   */\n  getText(el) {\n    return el.textContent;\n  }\n  /**\n   * @param {?} el\n   * @param {?} value\n   * @return {?}\n   */\n  setText(el, value) {\n    el.textContent = value;\n  }\n  /**\n   * @param {?} el\n   * @return {?}\n   */\n  getValue(el) {\n    return el.value;\n  }\n  /**\n   * @param {?} el\n   * @param {?} value\n   * @return {?}\n   */\n  setValue(el, value) {\n    el.value = value;\n  }\n  /**\n   * @param {?} el\n   * @return {?}\n   */\n  getChecked(el) {\n    return el.checked;\n  }\n  /**\n   * @param {?} el\n   * @param {?} value\n   * @return {?}\n   */\n  setChecked(el, value) {\n    el.checked = value;\n  }\n  /**\n   * @param {?} text\n   * @return {?}\n   */\n  createComment(text) {\n    return document.createComment(text);\n  }\n  /**\n   * @param {?} html\n   * @return {?}\n   */\n  createTemplate(html) {\n    const /** @type {?} */t = document.createElement('template');\n    t.innerHTML = html;\n    return t;\n  }\n  /**\n   * @param {?} tagName\n   * @param {?=} doc\n   * @return {?}\n   */\n  createElement(tagName, doc = document) {\n    return doc.createElement(tagName);\n  }\n  /**\n   * @param {?} ns\n   * @param {?} tagName\n   * @param {?=} doc\n   * @return {?}\n   */\n  createElementNS(ns, tagName, doc = document) {\n    return doc.createElementNS(ns, tagName);\n  }\n  /**\n   * @param {?} text\n   * @param {?=} doc\n   * @return {?}\n   */\n  createTextNode(text, doc = document) {\n    return doc.createTextNode(text);\n  }\n  /**\n   * @param {?} attrName\n   * @param {?} attrValue\n   * @param {?=} doc\n   * @return {?}\n   */\n  createScriptTag(attrName, attrValue, doc = document) {\n    const /** @type {?} */el = doc.createElement('SCRIPT');\n    el.setAttribute(attrName, attrValue);\n    return el;\n  }\n  /**\n   * @param {?} css\n   * @param {?=} doc\n   * @return {?}\n   */\n  createStyleElement(css, doc = document) {\n    const /** @type {?} */style = doc.createElement('style');\n    this.appendChild(style, this.createTextNode(css));\n    return style;\n  }\n  /**\n   * @param {?} el\n   * @return {?}\n   */\n  createShadowRoot(el) {\n    return el.createShadowRoot();\n  }\n  /**\n   * @param {?} el\n   * @return {?}\n   */\n  getShadowRoot(el) {\n    return el.shadowRoot;\n  }\n  /**\n   * @param {?} el\n   * @return {?}\n   */\n  getHost(el) {\n    return el.host;\n  }\n  /**\n   * @param {?} node\n   * @return {?}\n   */\n  clone(node) {\n    return node.cloneNode(true);\n  }\n  /**\n   * @param {?} element\n   * @param {?} name\n   * @return {?}\n   */\n  getElementsByClassName(element, name) {\n    return element.getElementsByClassName(name);\n  }\n  /**\n   * @param {?} element\n   * @param {?} name\n   * @return {?}\n   */\n  getElementsByTagName(element, name) {\n    return element.getElementsByTagName(name);\n  }\n  /**\n   * @param {?} element\n   * @return {?}\n   */\n  classList(element) {\n    return Array.prototype.slice.call(element.classList, 0);\n  }\n  /**\n   * @param {?} element\n   * @param {?} className\n   * @return {?}\n   */\n  addClass(element, className) {\n    element.classList.add(className);\n  }\n  /**\n   * @param {?} element\n   * @param {?} className\n   * @return {?}\n   */\n  removeClass(element, className) {\n    element.classList.remove(className);\n  }\n  /**\n   * @param {?} element\n   * @param {?} className\n   * @return {?}\n   */\n  hasClass(element, className) {\n    return element.classList.contains(className);\n  }\n  /**\n   * @param {?} element\n   * @param {?} styleName\n   * @param {?} styleValue\n   * @return {?}\n   */\n  setStyle(element, styleName, styleValue) {\n    element.style[styleName] = styleValue;\n  }\n  /**\n   * @param {?} element\n   * @param {?} stylename\n   * @return {?}\n   */\n  removeStyle(element, stylename) {\n    // IE requires '' instead of null\n    // see https://github.com/angular/angular/issues/7916\n    element.style[stylename] = '';\n  }\n  /**\n   * @param {?} element\n   * @param {?} stylename\n   * @return {?}\n   */\n  getStyle(element, stylename) {\n    return element.style[stylename];\n  }\n  /**\n   * @param {?} element\n   * @param {?} styleName\n   * @param {?=} styleValue\n   * @return {?}\n   */\n  hasStyle(element, styleName, styleValue) {\n    const /** @type {?} */value = this.getStyle(element, styleName) || '';\n    return styleValue ? value == styleValue : value.length > 0;\n  }\n  /**\n   * @param {?} element\n   * @return {?}\n   */\n  tagName(element) {\n    return element.tagName;\n  }\n  /**\n   * @param {?} element\n   * @return {?}\n   */\n  attributeMap(element) {\n    const /** @type {?} */res = new Map();\n    const /** @type {?} */elAttrs = element.attributes;\n    for (let /** @type {?} */i = 0; i < elAttrs.length; i++) {\n      const /** @type {?} */attrib = elAttrs[i];\n      res.set(attrib.name, attrib.value);\n    }\n    return res;\n  }\n  /**\n   * @param {?} element\n   * @param {?} attribute\n   * @return {?}\n   */\n  hasAttribute(element, attribute) {\n    return element.hasAttribute(attribute);\n  }\n  /**\n   * @param {?} element\n   * @param {?} ns\n   * @param {?} attribute\n   * @return {?}\n   */\n  hasAttributeNS(element, ns, attribute) {\n    return element.hasAttributeNS(ns, attribute);\n  }\n  /**\n   * @param {?} element\n   * @param {?} attribute\n   * @return {?}\n   */\n  getAttribute(element, attribute) {\n    return element.getAttribute(attribute);\n  }\n  /**\n   * @param {?} element\n   * @param {?} ns\n   * @param {?} name\n   * @return {?}\n   */\n  getAttributeNS(element, ns, name) {\n    return element.getAttributeNS(ns, name);\n  }\n  /**\n   * @param {?} element\n   * @param {?} name\n   * @param {?} value\n   * @return {?}\n   */\n  setAttribute(element, name, value) {\n    element.setAttribute(name, value);\n  }\n  /**\n   * @param {?} element\n   * @param {?} ns\n   * @param {?} name\n   * @param {?} value\n   * @return {?}\n   */\n  setAttributeNS(element, ns, name, value) {\n    element.setAttributeNS(ns, name, value);\n  }\n  /**\n   * @param {?} element\n   * @param {?} attribute\n   * @return {?}\n   */\n  removeAttribute(element, attribute) {\n    element.removeAttribute(attribute);\n  }\n  /**\n   * @param {?} element\n   * @param {?} ns\n   * @param {?} name\n   * @return {?}\n   */\n  removeAttributeNS(element, ns, name) {\n    element.removeAttributeNS(ns, name);\n  }\n  /**\n   * @param {?} el\n   * @return {?}\n   */\n  templateAwareRoot(el) {\n    return this.isTemplateElement(el) ? this.content(el) : el;\n  }\n  /**\n   * @return {?}\n   */\n  createHtmlDocument() {\n    return document.implementation.createHTMLDocument('fakeTitle');\n  }\n  /**\n   * @param {?} el\n   * @return {?}\n   */\n  getBoundingClientRect(el) {\n    try {\n      return el.getBoundingClientRect();\n    } catch (e) {\n      return {\n        top: 0,\n        bottom: 0,\n        left: 0,\n        right: 0,\n        width: 0,\n        height: 0\n      };\n    }\n  }\n  /**\n   * @param {?} doc\n   * @return {?}\n   */\n  getTitle(doc) {\n    return document.title;\n  }\n  /**\n   * @param {?} doc\n   * @param {?} newTitle\n   * @return {?}\n   */\n  setTitle(doc, newTitle) {\n    document.title = newTitle || '';\n  }\n  /**\n   * @param {?} n\n   * @param {?} selector\n   * @return {?}\n   */\n  elementMatches(n, selector) {\n    if (n instanceof HTMLElement) {\n      return n.matches && n.matches(selector) || n.msMatchesSelector && n.msMatchesSelector(selector) || n.webkitMatchesSelector && n.webkitMatchesSelector(selector);\n    }\n    return false;\n  }\n  /**\n   * @param {?} el\n   * @return {?}\n   */\n  isTemplateElement(el) {\n    return el instanceof HTMLElement && el.nodeName == 'TEMPLATE';\n  }\n  /**\n   * @param {?} node\n   * @return {?}\n   */\n  isTextNode(node) {\n    return node.nodeType === Node.TEXT_NODE;\n  }\n  /**\n   * @param {?} node\n   * @return {?}\n   */\n  isCommentNode(node) {\n    return node.nodeType === Node.COMMENT_NODE;\n  }\n  /**\n   * @param {?} node\n   * @return {?}\n   */\n  isElementNode(node) {\n    return node.nodeType === Node.ELEMENT_NODE;\n  }\n  /**\n   * @param {?} node\n   * @return {?}\n   */\n  hasShadowRoot(node) {\n    return node.shadowRoot != null && node instanceof HTMLElement;\n  }\n  /**\n   * @param {?} node\n   * @return {?}\n   */\n  isShadowRoot(node) {\n    return node instanceof DocumentFragment;\n  }\n  /**\n   * @param {?} node\n   * @return {?}\n   */\n  importIntoDoc(node) {\n    return document.importNode(this.templateAwareRoot(node), true);\n  }\n  /**\n   * @param {?} node\n   * @return {?}\n   */\n  adoptNode(node) {\n    return document.adoptNode(node);\n  }\n  /**\n   * @param {?} el\n   * @return {?}\n   */\n  getHref(el) {\n    return el.href;\n  }\n  /**\n   * @param {?} event\n   * @return {?}\n   */\n  getEventKey(event) {\n    let /** @type {?} */key = event.key;\n    if (key == null) {\n      key = event.keyIdentifier;\n      // keyIdentifier is defined in the old draft of DOM Level 3 Events implemented by Chrome and\n      // Safari cf\n      // http://www.w3.org/TR/2007/WD-DOM-Level-3-Events-20071221/events.html#Events-KeyboardEvents-Interfaces\n      if (key == null) {\n        return 'Unidentified';\n      }\n      if (key.startsWith('U+')) {\n        key = String.fromCharCode(parseInt(key.substring(2), 16));\n        if (event.location === DOM_KEY_LOCATION_NUMPAD && _chromeNumKeyPadMap.hasOwnProperty(key)) {\n          // There is a bug in Chrome for numeric keypad keys:\n          // https://code.google.com/p/chromium/issues/detail?id=155654\n          // 1, 2, 3 ... are reported as A, B, C ...\n          key = _chromeNumKeyPadMap[key];\n        }\n      }\n    }\n    return _keyMap[key] || key;\n  }\n  /**\n   * @param {?} doc\n   * @param {?} target\n   * @return {?}\n   */\n  getGlobalEventTarget(doc, target) {\n    if (target === 'window') {\n      return window;\n    }\n    if (target === 'document') {\n      return document;\n    }\n    if (target === 'body') {\n      return document.body;\n    }\n    return null;\n  }\n  /**\n   * @return {?}\n   */\n  getHistory() {\n    return window.history;\n  }\n  /**\n   * @return {?}\n   */\n  getLocation() {\n    return window.location;\n  }\n  /**\n   * @param {?} doc\n   * @return {?}\n   */\n  getBaseHref(doc) {\n    const /** @type {?} */href = getBaseElementHref();\n    return href == null ? null : relativePath(href);\n  }\n  /**\n   * @return {?}\n   */\n  resetBaseElement() {\n    baseElement = null;\n  }\n  /**\n   * @return {?}\n   */\n  getUserAgent() {\n    return window.navigator.userAgent;\n  }\n  /**\n   * @param {?} element\n   * @param {?} name\n   * @param {?} value\n   * @return {?}\n   */\n  setData(element, name, value) {\n    this.setAttribute(element, 'data-' + name, value);\n  }\n  /**\n   * @param {?} element\n   * @param {?} name\n   * @return {?}\n   */\n  getData(element, name) {\n    return this.getAttribute(element, 'data-' + name);\n  }\n  /**\n   * @param {?} element\n   * @return {?}\n   */\n  getComputedStyle(element) {\n    return getComputedStyle(element);\n  }\n  /**\n   * @return {?}\n   */\n  supportsWebAnimation() {\n    return typeof Element.prototype['animate'] === 'function';\n  }\n  /**\n   * @return {?}\n   */\n  performanceNow() {\n    // performance.now() is not available in all browsers, see\n    // http://caniuse.com/#search=performance.now\n    return window.performance && window.performance.now ? window.performance.now() : new Date().getTime();\n  }\n  /**\n   * @return {?}\n   */\n  supportsCookies() {\n    return true;\n  }\n  /**\n   * @param {?} name\n   * @return {?}\n   */\n  getCookie(name) {\n    return ɵparseCookieValue(document.cookie, name);\n  }\n  /**\n   * @param {?} name\n   * @param {?} value\n   * @return {?}\n   */\n  setCookie(name, value) {\n    // document.cookie is magical, assigning into it assigns/overrides one cookie value, but does\n    // not clear other cookies.\n    document.cookie = encodeURIComponent(name) + '=' + encodeURIComponent(value);\n  }\n}\nlet baseElement = null;\n/**\n * @return {?}\n */\nfunction getBaseElementHref() {\n  if (!baseElement) {\n    baseElement = document.querySelector('base');\n    if (!baseElement) {\n      return null;\n    }\n  }\n  return baseElement.getAttribute('href');\n}\n// based on urlUtils.js in AngularJS 1\nlet urlParsingNode;\n/**\n * @param {?} url\n * @return {?}\n */\nfunction relativePath(url) {\n  if (!urlParsingNode) {\n    urlParsingNode = document.createElement('a');\n  }\n  urlParsingNode.setAttribute('href', url);\n  return urlParsingNode.pathname.charAt(0) === '/' ? urlParsingNode.pathname : '/' + urlParsingNode.pathname;\n}\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * A DI Token representing the main rendering context. In a browser this is the DOM Document.\n *\n * Note: Document might not be available in the Application Context when Application and Rendering\n * Contexts are not the same (e.g. when running the application into a Web Worker).\n *\n * @deprecated import from `\\@angular/common` instead.\n */\nconst DOCUMENT$1 = DOCUMENT;\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n * @return {?}\n */\nfunction supportsState() {\n  return !!window.history.pushState;\n}\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * `PlatformLocation` encapsulates all of the direct calls to platform APIs.\n * This class should not be used directly by an application developer. Instead, use\n * {\\@link Location}.\n */\nclass BrowserPlatformLocation extends PlatformLocation {\n  /**\n   * @param {?} _doc\n   */\n  constructor(_doc) {\n    super();\n    this._doc = _doc;\n    this._init();\n  }\n  /**\n   * \\@internal\n   * @return {?}\n   */\n  _init() {\n    this._location = getDOM().getLocation();\n    this._history = getDOM().getHistory();\n  }\n  /**\n   * @return {?}\n   */\n  get location() {\n    return this._location;\n  }\n  /**\n   * @return {?}\n   */\n  getBaseHrefFromDOM() {\n    return getDOM().getBaseHref(this._doc);\n  }\n  /**\n   * @param {?} fn\n   * @return {?}\n   */\n  onPopState(fn) {\n    getDOM().getGlobalEventTarget(this._doc, 'window').addEventListener('popstate', fn, false);\n  }\n  /**\n   * @param {?} fn\n   * @return {?}\n   */\n  onHashChange(fn) {\n    getDOM().getGlobalEventTarget(this._doc, 'window').addEventListener('hashchange', fn, false);\n  }\n  /**\n   * @return {?}\n   */\n  get pathname() {\n    return this._location.pathname;\n  }\n  /**\n   * @return {?}\n   */\n  get search() {\n    return this._location.search;\n  }\n  /**\n   * @return {?}\n   */\n  get hash() {\n    return this._location.hash;\n  }\n  /**\n   * @param {?} newPath\n   * @return {?}\n   */\n  set pathname(newPath) {\n    this._location.pathname = newPath;\n  }\n  /**\n   * @param {?} state\n   * @param {?} title\n   * @param {?} url\n   * @return {?}\n   */\n  pushState(state, title, url) {\n    if (supportsState()) {\n      this._history.pushState(state, title, url);\n    } else {\n      this._location.hash = url;\n    }\n  }\n  /**\n   * @param {?} state\n   * @param {?} title\n   * @param {?} url\n   * @return {?}\n   */\n  replaceState(state, title, url) {\n    if (supportsState()) {\n      this._history.replaceState(state, title, url);\n    } else {\n      this._location.hash = url;\n    }\n  }\n  /**\n   * @return {?}\n   */\n  forward() {\n    this._history.forward();\n  }\n  /**\n   * @return {?}\n   */\n  back() {\n    this._history.back();\n  }\n}\n\n/**\n * @nocollapse\n */\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * A service that can be used to get and add meta tags.\n *\n * \\@experimental\n */\nclass Meta {\n  /**\n   * @param {?} _doc\n   */\n  constructor(_doc) {\n    this._doc = _doc;\n    this._dom = getDOM();\n  }\n  /**\n   * @param {?} tag\n   * @param {?=} forceCreation\n   * @return {?}\n   */\n  addTag(tag, forceCreation = false) {\n    if (!tag) return null;\n    return this._getOrCreateElement(tag, forceCreation);\n  }\n  /**\n   * @param {?} tags\n   * @param {?=} forceCreation\n   * @return {?}\n   */\n  addTags(tags, forceCreation = false) {\n    if (!tags) return [];\n    return tags.reduce((result, tag) => {\n      if (tag) {\n        result.push(this._getOrCreateElement(tag, forceCreation));\n      }\n      return result;\n    }, []);\n  }\n  /**\n   * @param {?} attrSelector\n   * @return {?}\n   */\n  getTag(attrSelector) {\n    if (!attrSelector) return null;\n    return this._dom.querySelector(this._doc, `meta[${attrSelector}]`);\n  }\n  /**\n   * @param {?} attrSelector\n   * @return {?}\n   */\n  getTags(attrSelector) {\n    if (!attrSelector) return [];\n    const /** @type {?} */list /*NodeList*/ = this._dom.querySelectorAll(this._doc, `meta[${attrSelector}]`);\n    return list ? [].slice.call(list) : [];\n  }\n  /**\n   * @param {?} tag\n   * @param {?=} selector\n   * @return {?}\n   */\n  updateTag(tag, selector) {\n    if (!tag) return null;\n    selector = selector || this._parseSelector(tag);\n    const /** @type {?} */meta = this.getTag(selector);\n    if (meta) {\n      return this._setMetaElementAttributes(tag, meta);\n    }\n    return this._getOrCreateElement(tag, true);\n  }\n  /**\n   * @param {?} attrSelector\n   * @return {?}\n   */\n  removeTag(attrSelector) {\n    this.removeTagElement( /** @type {?} */this.getTag(attrSelector));\n  }\n  /**\n   * @param {?} meta\n   * @return {?}\n   */\n  removeTagElement(meta) {\n    if (meta) {\n      this._dom.remove(meta);\n    }\n  }\n  /**\n   * @param {?} meta\n   * @param {?=} forceCreation\n   * @return {?}\n   */\n  _getOrCreateElement(meta, forceCreation = false) {\n    if (!forceCreation) {\n      const /** @type {?} */selector = this._parseSelector(meta);\n      const /** @type {?} */elem = this.getTag(selector);\n      // It's allowed to have multiple elements with the same name so it's not enough to\n      // just check that element with the same name already present on the page. We also need to\n      // check if element has tag attributes\n      if (elem && this._containsAttributes(meta, elem)) return elem;\n    }\n    const /** @type {?} */element = this._dom.createElement('meta');\n    this._setMetaElementAttributes(meta, element);\n    const /** @type {?} */head = this._dom.getElementsByTagName(this._doc, 'head')[0];\n    this._dom.appendChild(head, element);\n    return element;\n  }\n  /**\n   * @param {?} tag\n   * @param {?} el\n   * @return {?}\n   */\n  _setMetaElementAttributes(tag, el) {\n    Object.keys(tag).forEach(prop => this._dom.setAttribute(el, prop, tag[prop]));\n    return el;\n  }\n  /**\n   * @param {?} tag\n   * @return {?}\n   */\n  _parseSelector(tag) {\n    const /** @type {?} */attr = tag.name ? 'name' : 'property';\n    return `${attr}=\"${tag[attr]}\"`;\n  }\n  /**\n   * @param {?} tag\n   * @param {?} elem\n   * @return {?}\n   */\n  _containsAttributes(tag, elem) {\n    return Object.keys(tag).every(key => this._dom.getAttribute(elem, key) === tag[key]);\n  }\n}\n\n/**\n * @nocollapse\n */\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * An id that identifies a particular application being bootstrapped, that should\n * match across the client/server boundary.\n */\nconst TRANSITION_ID = new InjectionToken('TRANSITION_ID');\n/**\n * @param {?} transitionId\n * @param {?} document\n * @param {?} injector\n * @return {?}\n */\nfunction appInitializerFactory(transitionId, document, injector) {\n  return () => {\n    // Wait for all application initializers to be completed before removing the styles set by\n    // the server.\n    injector.get(ApplicationInitStatus).donePromise.then(() => {\n      const /** @type {?} */dom = getDOM();\n      const /** @type {?} */styles = Array.prototype.slice.apply(dom.querySelectorAll(document, `style[ng-transition]`));\n      styles.filter(el => dom.getAttribute(el, 'ng-transition') === transitionId).forEach(el => dom.remove(el));\n    });\n  };\n}\nconst SERVER_TRANSITION_PROVIDERS = [{\n  provide: APP_INITIALIZER,\n  useFactory: appInitializerFactory,\n  deps: [TRANSITION_ID, DOCUMENT$1, Injector],\n  multi: true\n}];\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nclass BrowserGetTestability {\n  /**\n   * @return {?}\n   */\n  static init() {\n    setTestabilityGetter(new BrowserGetTestability());\n  }\n  /**\n   * @param {?} registry\n   * @return {?}\n   */\n  addToWindow(registry) {\n    ɵglobal['getAngularTestability'] = (elem, findInAncestors = true) => {\n      const /** @type {?} */testability = registry.findTestabilityInTree(elem, findInAncestors);\n      if (testability == null) {\n        throw new Error('Could not find testability for element.');\n      }\n      return testability;\n    };\n    ɵglobal['getAllAngularTestabilities'] = () => registry.getAllTestabilities();\n    ɵglobal['getAllAngularRootElements'] = () => registry.getAllRootElements();\n    const /** @type {?} */whenAllStable = (callback /** TODO #9100 */) => {\n      const /** @type {?} */testabilities = ɵglobal['getAllAngularTestabilities']();\n      let /** @type {?} */count = testabilities.length;\n      let /** @type {?} */didWork = false;\n      const /** @type {?} */decrement = function (didWork_ /** TODO #9100 */) {\n        didWork = didWork || didWork_;\n        count--;\n        if (count == 0) {\n          callback(didWork);\n        }\n      };\n      testabilities.forEach(function (testability /** TODO #9100 */) {\n        testability.whenStable(decrement);\n      });\n    };\n    if (!ɵglobal['frameworkStabilizers']) {\n      ɵglobal['frameworkStabilizers'] = [];\n    }\n    ɵglobal['frameworkStabilizers'].push(whenAllStable);\n  }\n  /**\n   * @param {?} registry\n   * @param {?} elem\n   * @param {?} findInAncestors\n   * @return {?}\n   */\n  findTestabilityInTree(registry, elem, findInAncestors) {\n    if (elem == null) {\n      return null;\n    }\n    const /** @type {?} */t = registry.getTestability(elem);\n    if (t != null) {\n      return t;\n    } else if (!findInAncestors) {\n      return null;\n    }\n    if (getDOM().isShadowRoot(elem)) {\n      return this.findTestabilityInTree(registry, getDOM().getHost(elem), true);\n    }\n    return this.findTestabilityInTree(registry, getDOM().parentElement(elem), true);\n  }\n}\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * A service that can be used to get and set the title of a current HTML document.\n *\n * Since an Angular application can't be bootstrapped on the entire HTML document (`<html>` tag)\n * it is not possible to bind to the `text` property of the `HTMLTitleElement` elements\n * (representing the `<title>` tag). Instead, this service can be used to set and get the current\n * title value.\n *\n * \\@experimental\n */\nclass Title {\n  /**\n   * @param {?} _doc\n   */\n  constructor(_doc) {\n    this._doc = _doc;\n  }\n  /**\n   * Get the title of the current HTML document.\n   * @return {?}\n   */\n  getTitle() {\n    return getDOM().getTitle(this._doc);\n  }\n  /**\n   * Set the title of the current HTML document.\n   * @param {?} newTitle\n   * @return {?}\n   */\n  setTitle(newTitle) {\n    getDOM().setTitle(this._doc, newTitle);\n  }\n}\n\n/**\n * @nocollapse\n */\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * @param {?} input\n * @return {?}\n */\n\n/**\n * @param {?} input\n * @return {?}\n */\n/**\n * Exports the value under a given `name` in the global property `ng`. For example `ng.probe` if\n * `name` is `'probe'`.\n * @param {?} name Name under which it will be exported. Keep in mind this will be a property of the\n * global `ng` object.\n * @param {?} value The value to export.\n * @return {?}\n */\nfunction exportNgVar(name, value) {\n  if (!ng) {\n    ɵglobal['ng'] = ng = ɵglobal['ng'] || {};\n  }\n  ng[name] = value;\n}\nlet ng;\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nconst CORE_TOKENS = {\n  'ApplicationRef': ApplicationRef,\n  'NgZone': NgZone\n};\nconst INSPECT_GLOBAL_NAME = 'probe';\nconst CORE_TOKENS_GLOBAL_NAME = 'coreTokens';\n/**\n * Returns a {\\@link DebugElement} for the given native DOM element, or\n * null if the given native element does not have an Angular view associated\n * with it.\n * @param {?} element\n * @return {?}\n */\nfunction inspectNativeElement(element) {\n  return getDebugNode(element);\n}\n/**\n * Deprecated. Use the one from '\\@angular/core'.\n * @deprecated\n */\nclass NgProbeToken$1 {\n  /**\n   * @param {?} name\n   * @param {?} token\n   */\n  constructor(name, token) {\n    this.name = name;\n    this.token = token;\n  }\n}\n/**\n * @param {?} extraTokens\n * @param {?} coreTokens\n * @return {?}\n */\nfunction _createNgProbe(extraTokens, coreTokens) {\n  const /** @type {?} */tokens = (extraTokens || []).concat(coreTokens || []);\n  exportNgVar(INSPECT_GLOBAL_NAME, inspectNativeElement);\n  exportNgVar(CORE_TOKENS_GLOBAL_NAME, Object.assign({}, CORE_TOKENS, _ngProbeTokensToMap(tokens || [])));\n  return () => inspectNativeElement;\n}\n/**\n * @param {?} tokens\n * @return {?}\n */\nfunction _ngProbeTokensToMap(tokens) {\n  return tokens.reduce((prev, t) => (prev[t.name] = t.token, prev), {});\n}\n/**\n * Providers which support debugging Angular applications (e.g. via `ng.probe`).\n */\nconst ELEMENT_PROBE_PROVIDERS = [{\n  provide: APP_INITIALIZER,\n  useFactory: _createNgProbe,\n  deps: [[NgProbeToken$1, new Optional()], [NgProbeToken, new Optional()]],\n  multi: true\n}];\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * \\@stable\n */\nconst EVENT_MANAGER_PLUGINS = new InjectionToken('EventManagerPlugins');\n/**\n * \\@stable\n */\nclass EventManager {\n  /**\n   * @param {?} plugins\n   * @param {?} _zone\n   */\n  constructor(plugins, _zone) {\n    this._zone = _zone;\n    this._eventNameToPlugin = new Map();\n    plugins.forEach(p => p.manager = this);\n    this._plugins = plugins.slice().reverse();\n  }\n  /**\n   * @param {?} element\n   * @param {?} eventName\n   * @param {?} handler\n   * @return {?}\n   */\n  addEventListener(element, eventName, handler) {\n    const /** @type {?} */plugin = this._findPluginFor(eventName);\n    return plugin.addEventListener(element, eventName, handler);\n  }\n  /**\n   * @param {?} target\n   * @param {?} eventName\n   * @param {?} handler\n   * @return {?}\n   */\n  addGlobalEventListener(target, eventName, handler) {\n    const /** @type {?} */plugin = this._findPluginFor(eventName);\n    return plugin.addGlobalEventListener(target, eventName, handler);\n  }\n  /**\n   * @return {?}\n   */\n  getZone() {\n    return this._zone;\n  }\n  /**\n   * \\@internal\n   * @param {?} eventName\n   * @return {?}\n   */\n  _findPluginFor(eventName) {\n    const /** @type {?} */plugin = this._eventNameToPlugin.get(eventName);\n    if (plugin) {\n      return plugin;\n    }\n    const /** @type {?} */plugins = this._plugins;\n    for (let /** @type {?} */i = 0; i < plugins.length; i++) {\n      const /** @type {?} */plugin = plugins[i];\n      if (plugin.supports(eventName)) {\n        this._eventNameToPlugin.set(eventName, plugin);\n        return plugin;\n      }\n    }\n    throw new Error(`No event manager plugin found for event ${eventName}`);\n  }\n}\n\n/**\n * @nocollapse\n */\n\n/**\n * @abstract\n */\nclass EventManagerPlugin {\n  /**\n   * @param {?} _doc\n   */\n  constructor(_doc) {\n    this._doc = _doc;\n  }\n  /**\n   * @abstract\n   * @param {?} eventName\n   * @return {?}\n   */\n  supports(eventName) {}\n  /**\n   * @abstract\n   * @param {?} element\n   * @param {?} eventName\n   * @param {?} handler\n   * @return {?}\n   */\n  addEventListener(element, eventName, handler) {}\n  /**\n   * @param {?} element\n   * @param {?} eventName\n   * @param {?} handler\n   * @return {?}\n   */\n  addGlobalEventListener(element, eventName, handler) {\n    const /** @type {?} */target = getDOM().getGlobalEventTarget(this._doc, element);\n    if (!target) {\n      throw new Error(`Unsupported event target ${target} for event ${eventName}`);\n    }\n    return this.addEventListener(target, eventName, handler);\n  }\n}\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nclass SharedStylesHost {\n  constructor() {\n    /**\n     * \\@internal\n     */\n    this._stylesSet = new Set();\n  }\n  /**\n   * @param {?} styles\n   * @return {?}\n   */\n  addStyles(styles) {\n    const /** @type {?} */additions = new Set();\n    styles.forEach(style => {\n      if (!this._stylesSet.has(style)) {\n        this._stylesSet.add(style);\n        additions.add(style);\n      }\n    });\n    this.onStylesAdded(additions);\n  }\n  /**\n   * @param {?} additions\n   * @return {?}\n   */\n  onStylesAdded(additions) {}\n  /**\n   * @return {?}\n   */\n  getAllStyles() {\n    return Array.from(this._stylesSet);\n  }\n}\n\n/**\n * @nocollapse\n */\n\nclass DomSharedStylesHost extends SharedStylesHost {\n  /**\n   * @param {?} _doc\n   */\n  constructor(_doc) {\n    super();\n    this._doc = _doc;\n    this._hostNodes = new Set();\n    this._styleNodes = new Set();\n    this._hostNodes.add(_doc.head);\n  }\n  /**\n   * @param {?} styles\n   * @param {?} host\n   * @return {?}\n   */\n  _addStylesToHost(styles, host) {\n    styles.forEach(style => {\n      const /** @type {?} */styleEl = this._doc.createElement('style');\n      styleEl.textContent = style;\n      this._styleNodes.add(host.appendChild(styleEl));\n    });\n  }\n  /**\n   * @param {?} hostNode\n   * @return {?}\n   */\n  addHost(hostNode) {\n    this._addStylesToHost(this._stylesSet, hostNode);\n    this._hostNodes.add(hostNode);\n  }\n  /**\n   * @param {?} hostNode\n   * @return {?}\n   */\n  removeHost(hostNode) {\n    this._hostNodes.delete(hostNode);\n  }\n  /**\n   * @param {?} additions\n   * @return {?}\n   */\n  onStylesAdded(additions) {\n    this._hostNodes.forEach(hostNode => this._addStylesToHost(additions, hostNode));\n  }\n  /**\n   * @return {?}\n   */\n  ngOnDestroy() {\n    this._styleNodes.forEach(styleNode => getDOM().remove(styleNode));\n  }\n}\n\n/**\n * @nocollapse\n */\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nconst NAMESPACE_URIS = {\n  'svg': 'http://www.w3.org/2000/svg',\n  'xhtml': 'http://www.w3.org/1999/xhtml',\n  'xlink': 'http://www.w3.org/1999/xlink',\n  'xml': 'http://www.w3.org/XML/1998/namespace',\n  'xmlns': 'http://www.w3.org/2000/xmlns/'\n};\nconst COMPONENT_REGEX = /%COMP%/g;\nconst COMPONENT_VARIABLE = '%COMP%';\nconst HOST_ATTR = `_nghost-${COMPONENT_VARIABLE}`;\nconst CONTENT_ATTR = `_ngcontent-${COMPONENT_VARIABLE}`;\n/**\n * @param {?} componentShortId\n * @return {?}\n */\nfunction shimContentAttribute(componentShortId) {\n  return CONTENT_ATTR.replace(COMPONENT_REGEX, componentShortId);\n}\n/**\n * @param {?} componentShortId\n * @return {?}\n */\nfunction shimHostAttribute(componentShortId) {\n  return HOST_ATTR.replace(COMPONENT_REGEX, componentShortId);\n}\n/**\n * @param {?} compId\n * @param {?} styles\n * @param {?} target\n * @return {?}\n */\nfunction flattenStyles(compId, styles, target) {\n  for (let /** @type {?} */i = 0; i < styles.length; i++) {\n    let /** @type {?} */style = styles[i];\n    if (Array.isArray(style)) {\n      flattenStyles(compId, style, target);\n    } else {\n      style = style.replace(COMPONENT_REGEX, compId);\n      target.push(style);\n    }\n  }\n  return target;\n}\n/**\n * @param {?} eventHandler\n * @return {?}\n */\nfunction decoratePreventDefault(eventHandler) {\n  return event => {\n    const /** @type {?} */allowDefaultBehavior = eventHandler(event);\n    if (allowDefaultBehavior === false) {\n      // TODO(tbosch): move preventDefault into event plugins...\n      event.preventDefault();\n      event.returnValue = false;\n    }\n  };\n}\nclass DomRendererFactory2 {\n  /**\n   * @param {?} eventManager\n   * @param {?} sharedStylesHost\n   */\n  constructor(eventManager, sharedStylesHost) {\n    this.eventManager = eventManager;\n    this.sharedStylesHost = sharedStylesHost;\n    this.rendererByCompId = new Map();\n    this.defaultRenderer = new DefaultDomRenderer2(eventManager);\n  }\n  /**\n   * @param {?} element\n   * @param {?} type\n   * @return {?}\n   */\n  createRenderer(element, type) {\n    if (!element || !type) {\n      return this.defaultRenderer;\n    }\n    switch (type.encapsulation) {\n      case ViewEncapsulation.Emulated:\n        {\n          let /** @type {?} */renderer = this.rendererByCompId.get(type.id);\n          if (!renderer) {\n            renderer = new EmulatedEncapsulationDomRenderer2(this.eventManager, this.sharedStylesHost, type);\n            this.rendererByCompId.set(type.id, renderer);\n          }\n          renderer.applyToHost(element);\n          return renderer;\n        }\n      case ViewEncapsulation.Native:\n        return new ShadowDomRenderer(this.eventManager, this.sharedStylesHost, element, type);\n      default:\n        {\n          if (!this.rendererByCompId.has(type.id)) {\n            const /** @type {?} */styles = flattenStyles(type.id, type.styles, []);\n            this.sharedStylesHost.addStyles(styles);\n            this.rendererByCompId.set(type.id, this.defaultRenderer);\n          }\n          return this.defaultRenderer;\n        }\n    }\n  }\n  /**\n   * @return {?}\n   */\n  begin() {}\n  /**\n   * @return {?}\n   */\n  end() {}\n}\n\n/**\n * @nocollapse\n */\n\nclass DefaultDomRenderer2 {\n  /**\n   * @param {?} eventManager\n   */\n  constructor(eventManager) {\n    this.eventManager = eventManager;\n    this.data = Object.create(null);\n  }\n  /**\n   * @return {?}\n   */\n  destroy() {}\n  /**\n   * @param {?} name\n   * @param {?=} namespace\n   * @return {?}\n   */\n  createElement(name, namespace) {\n    if (namespace) {\n      return document.createElementNS(NAMESPACE_URIS[namespace], name);\n    }\n    return document.createElement(name);\n  }\n  /**\n   * @param {?} value\n   * @return {?}\n   */\n  createComment(value) {\n    return document.createComment(value);\n  }\n  /**\n   * @param {?} value\n   * @return {?}\n   */\n  createText(value) {\n    return document.createTextNode(value);\n  }\n  /**\n   * @param {?} parent\n   * @param {?} newChild\n   * @return {?}\n   */\n  appendChild(parent, newChild) {\n    parent.appendChild(newChild);\n  }\n  /**\n   * @param {?} parent\n   * @param {?} newChild\n   * @param {?} refChild\n   * @return {?}\n   */\n  insertBefore(parent, newChild, refChild) {\n    if (parent) {\n      parent.insertBefore(newChild, refChild);\n    }\n  }\n  /**\n   * @param {?} parent\n   * @param {?} oldChild\n   * @return {?}\n   */\n  removeChild(parent, oldChild) {\n    if (parent) {\n      parent.removeChild(oldChild);\n    }\n  }\n  /**\n   * @param {?} selectorOrNode\n   * @return {?}\n   */\n  selectRootElement(selectorOrNode) {\n    let /** @type {?} */el = typeof selectorOrNode === 'string' ? document.querySelector(selectorOrNode) : selectorOrNode;\n    if (!el) {\n      throw new Error(`The selector \"${selectorOrNode}\" did not match any elements`);\n    }\n    el.textContent = '';\n    return el;\n  }\n  /**\n   * @param {?} node\n   * @return {?}\n   */\n  parentNode(node) {\n    return node.parentNode;\n  }\n  /**\n   * @param {?} node\n   * @return {?}\n   */\n  nextSibling(node) {\n    return node.nextSibling;\n  }\n  /**\n   * @param {?} el\n   * @param {?} name\n   * @param {?} value\n   * @param {?=} namespace\n   * @return {?}\n   */\n  setAttribute(el, name, value, namespace) {\n    if (namespace) {\n      name = `${namespace}:${name}`;\n      const /** @type {?} */namespaceUri = NAMESPACE_URIS[namespace];\n      if (namespaceUri) {\n        el.setAttributeNS(namespaceUri, name, value);\n      } else {\n        el.setAttribute(name, value);\n      }\n    } else {\n      el.setAttribute(name, value);\n    }\n  }\n  /**\n   * @param {?} el\n   * @param {?} name\n   * @param {?=} namespace\n   * @return {?}\n   */\n  removeAttribute(el, name, namespace) {\n    if (namespace) {\n      const /** @type {?} */namespaceUri = NAMESPACE_URIS[namespace];\n      if (namespaceUri) {\n        el.removeAttributeNS(namespaceUri, name);\n      } else {\n        el.removeAttribute(`${namespace}:${name}`);\n      }\n    } else {\n      el.removeAttribute(name);\n    }\n  }\n  /**\n   * @param {?} el\n   * @param {?} name\n   * @return {?}\n   */\n  addClass(el, name) {\n    el.classList.add(name);\n  }\n  /**\n   * @param {?} el\n   * @param {?} name\n   * @return {?}\n   */\n  removeClass(el, name) {\n    el.classList.remove(name);\n  }\n  /**\n   * @param {?} el\n   * @param {?} style\n   * @param {?} value\n   * @param {?} flags\n   * @return {?}\n   */\n  setStyle(el, style, value, flags) {\n    if (flags & RendererStyleFlags2.DashCase) {\n      el.style.setProperty(style, value, !!(flags & RendererStyleFlags2.Important) ? 'important' : '');\n    } else {\n      el.style[style] = value;\n    }\n  }\n  /**\n   * @param {?} el\n   * @param {?} style\n   * @param {?} flags\n   * @return {?}\n   */\n  removeStyle(el, style, flags) {\n    if (flags & RendererStyleFlags2.DashCase) {\n      el.style.removeProperty(style);\n    } else {\n      // IE requires '' instead of null\n      // see https://github.com/angular/angular/issues/7916\n      el.style[style] = '';\n    }\n  }\n  /**\n   * @param {?} el\n   * @param {?} name\n   * @param {?} value\n   * @return {?}\n   */\n  setProperty(el, name, value) {\n    checkNoSyntheticProp(name, 'property');\n    el[name] = value;\n  }\n  /**\n   * @param {?} node\n   * @param {?} value\n   * @return {?}\n   */\n  setValue(node, value) {\n    node.nodeValue = value;\n  }\n  /**\n   * @param {?} target\n   * @param {?} event\n   * @param {?} callback\n   * @return {?}\n   */\n  listen(target, event, callback) {\n    checkNoSyntheticProp(event, 'listener');\n    if (typeof target === 'string') {\n      return this.eventManager.addGlobalEventListener(target, event, decoratePreventDefault(callback));\n    }\n    return this.eventManager.addEventListener(target, event, decoratePreventDefault(callback));\n  }\n}\nconst AT_CHARCODE = '@'.charCodeAt(0);\n/**\n * @param {?} name\n * @param {?} nameKind\n * @return {?}\n */\nfunction checkNoSyntheticProp(name, nameKind) {\n  if (name.charCodeAt(0) === AT_CHARCODE) {\n    throw new Error(`Found the synthetic ${nameKind} ${name}. Please include either \"BrowserAnimationsModule\" or \"NoopAnimationsModule\" in your application.`);\n  }\n}\nclass EmulatedEncapsulationDomRenderer2 extends DefaultDomRenderer2 {\n  /**\n   * @param {?} eventManager\n   * @param {?} sharedStylesHost\n   * @param {?} component\n   */\n  constructor(eventManager, sharedStylesHost, component) {\n    super(eventManager);\n    this.component = component;\n    const styles = flattenStyles(component.id, component.styles, []);\n    sharedStylesHost.addStyles(styles);\n    this.contentAttr = shimContentAttribute(component.id);\n    this.hostAttr = shimHostAttribute(component.id);\n  }\n  /**\n   * @param {?} element\n   * @return {?}\n   */\n  applyToHost(element) {\n    super.setAttribute(element, this.hostAttr, '');\n  }\n  /**\n   * @param {?} parent\n   * @param {?} name\n   * @return {?}\n   */\n  createElement(parent, name) {\n    const /** @type {?} */el = super.createElement(parent, name);\n    super.setAttribute(el, this.contentAttr, '');\n    return el;\n  }\n}\nclass ShadowDomRenderer extends DefaultDomRenderer2 {\n  /**\n   * @param {?} eventManager\n   * @param {?} sharedStylesHost\n   * @param {?} hostEl\n   * @param {?} component\n   */\n  constructor(eventManager, sharedStylesHost, hostEl, component) {\n    super(eventManager);\n    this.sharedStylesHost = sharedStylesHost;\n    this.hostEl = hostEl;\n    this.component = component;\n    this.shadowRoot = hostEl.createShadowRoot();\n    this.sharedStylesHost.addHost(this.shadowRoot);\n    const styles = flattenStyles(component.id, component.styles, []);\n    for (let i = 0; i < styles.length; i++) {\n      const styleEl = document.createElement('style');\n      styleEl.textContent = styles[i];\n      this.shadowRoot.appendChild(styleEl);\n    }\n  }\n  /**\n   * @param {?} node\n   * @return {?}\n   */\n  nodeOrShadowRoot(node) {\n    return node === this.hostEl ? this.shadowRoot : node;\n  }\n  /**\n   * @return {?}\n   */\n  destroy() {\n    this.sharedStylesHost.removeHost(this.shadowRoot);\n  }\n  /**\n   * @param {?} parent\n   * @param {?} newChild\n   * @return {?}\n   */\n  appendChild(parent, newChild) {\n    return super.appendChild(this.nodeOrShadowRoot(parent), newChild);\n  }\n  /**\n   * @param {?} parent\n   * @param {?} newChild\n   * @param {?} refChild\n   * @return {?}\n   */\n  insertBefore(parent, newChild, refChild) {\n    return super.insertBefore(this.nodeOrShadowRoot(parent), newChild, refChild);\n  }\n  /**\n   * @param {?} parent\n   * @param {?} oldChild\n   * @return {?}\n   */\n  removeChild(parent, oldChild) {\n    return super.removeChild(this.nodeOrShadowRoot(parent), oldChild);\n  }\n  /**\n   * @param {?} node\n   * @return {?}\n   */\n  parentNode(node) {\n    return this.nodeOrShadowRoot(super.parentNode(this.nodeOrShadowRoot(node)));\n  }\n}\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nclass DomEventsPlugin extends EventManagerPlugin {\n  /**\n   * @param {?} doc\n   */\n  constructor(doc) {\n    super(doc);\n  }\n  /**\n   * @param {?} eventName\n   * @return {?}\n   */\n  supports(eventName) {\n    return true;\n  }\n  /**\n   * @param {?} element\n   * @param {?} eventName\n   * @param {?} handler\n   * @return {?}\n   */\n  addEventListener(element, eventName, handler) {\n    element.addEventListener(eventName, /** @type {?} */handler, false);\n    return () => element.removeEventListener(eventName, /** @type {?} */handler, false);\n  }\n}\n\n/**\n * @nocollapse\n */\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nconst EVENT_NAMES = {\n  // pan\n  'pan': true,\n  'panstart': true,\n  'panmove': true,\n  'panend': true,\n  'pancancel': true,\n  'panleft': true,\n  'panright': true,\n  'panup': true,\n  'pandown': true,\n  // pinch\n  'pinch': true,\n  'pinchstart': true,\n  'pinchmove': true,\n  'pinchend': true,\n  'pinchcancel': true,\n  'pinchin': true,\n  'pinchout': true,\n  // press\n  'press': true,\n  'pressup': true,\n  // rotate\n  'rotate': true,\n  'rotatestart': true,\n  'rotatemove': true,\n  'rotateend': true,\n  'rotatecancel': true,\n  // swipe\n  'swipe': true,\n  'swipeleft': true,\n  'swiperight': true,\n  'swipeup': true,\n  'swipedown': true,\n  // tap\n  'tap': true\n};\n/**\n * A DI token that you can use to provide{\\@link HammerGestureConfig} to Angular. Use it to configure\n * Hammer gestures.\n *\n * \\@experimental\n */\nconst HAMMER_GESTURE_CONFIG = new InjectionToken('HammerGestureConfig');\n/**\n * \\@experimental\n */\nclass HammerGestureConfig {\n  constructor() {\n    this.events = [];\n    this.overrides = {};\n  }\n  /**\n   * @param {?} element\n   * @return {?}\n   */\n  buildHammer(element) {\n    const /** @type {?} */mc = new Hammer(element);\n    mc.get('pinch').set({\n      enable: true\n    });\n    mc.get('rotate').set({\n      enable: true\n    });\n    for (const /** @type {?} */eventName in this.overrides) {\n      mc.get(eventName).set(this.overrides[eventName]);\n    }\n    return mc;\n  }\n}\n\n/**\n * @nocollapse\n */\n\nclass HammerGesturesPlugin extends EventManagerPlugin {\n  /**\n   * @param {?} doc\n   * @param {?} _config\n   */\n  constructor(doc, _config) {\n    super(doc);\n    this._config = _config;\n  }\n  /**\n   * @param {?} eventName\n   * @return {?}\n   */\n  supports(eventName) {\n    if (!EVENT_NAMES.hasOwnProperty(eventName.toLowerCase()) && !this.isCustomEvent(eventName)) {\n      return false;\n    }\n    if (!window.Hammer) {\n      throw new Error(`Hammer.js is not loaded, can not bind ${eventName} event`);\n    }\n    return true;\n  }\n  /**\n   * @param {?} element\n   * @param {?} eventName\n   * @param {?} handler\n   * @return {?}\n   */\n  addEventListener(element, eventName, handler) {\n    const /** @type {?} */zone = this.manager.getZone();\n    eventName = eventName.toLowerCase();\n    return zone.runOutsideAngular(() => {\n      // Creating the manager bind events, must be done outside of angular\n      const /** @type {?} */mc = this._config.buildHammer(element);\n      const /** @type {?} */callback = function (eventObj) {\n        zone.runGuarded(function () {\n          handler(eventObj);\n        });\n      };\n      mc.on(eventName, callback);\n      return () => mc.off(eventName, callback);\n    });\n  }\n  /**\n   * @param {?} eventName\n   * @return {?}\n   */\n  isCustomEvent(eventName) {\n    return this._config.events.indexOf(eventName) > -1;\n  }\n}\n\n/**\n * @nocollapse\n */\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nconst MODIFIER_KEYS = ['alt', 'control', 'meta', 'shift'];\nconst MODIFIER_KEY_GETTERS = {\n  'alt': event => event.altKey,\n  'control': event => event.ctrlKey,\n  'meta': event => event.metaKey,\n  'shift': event => event.shiftKey\n};\n/**\n * \\@experimental\n */\nclass KeyEventsPlugin extends EventManagerPlugin {\n  /**\n   * @param {?} doc\n   */\n  constructor(doc) {\n    super(doc);\n  }\n  /**\n   * @param {?} eventName\n   * @return {?}\n   */\n  supports(eventName) {\n    return KeyEventsPlugin.parseEventName(eventName) != null;\n  }\n  /**\n   * @param {?} element\n   * @param {?} eventName\n   * @param {?} handler\n   * @return {?}\n   */\n  addEventListener(element, eventName, handler) {\n    const /** @type {?} */parsedEvent = KeyEventsPlugin.parseEventName(eventName);\n    const /** @type {?} */outsideHandler = KeyEventsPlugin.eventCallback(parsedEvent['fullKey'], handler, this.manager.getZone());\n    return this.manager.getZone().runOutsideAngular(() => {\n      return getDOM().onAndCancel(element, parsedEvent['domEventName'], outsideHandler);\n    });\n  }\n  /**\n   * @param {?} eventName\n   * @return {?}\n   */\n  static parseEventName(eventName) {\n    const /** @type {?} */parts = eventName.toLowerCase().split('.');\n    const /** @type {?} */domEventName = parts.shift();\n    if (parts.length === 0 || !(domEventName === 'keydown' || domEventName === 'keyup')) {\n      return null;\n    }\n    const /** @type {?} */key = KeyEventsPlugin._normalizeKey( /** @type {?} */parts.pop());\n    let /** @type {?} */fullKey = '';\n    MODIFIER_KEYS.forEach(modifierName => {\n      const /** @type {?} */index = parts.indexOf(modifierName);\n      if (index > -1) {\n        parts.splice(index, 1);\n        fullKey += modifierName + '.';\n      }\n    });\n    fullKey += key;\n    if (parts.length != 0 || key.length === 0) {\n      // returning null instead of throwing to let another plugin process the event\n      return null;\n    }\n    const /** @type {?} */result = {};\n    result['domEventName'] = domEventName;\n    result['fullKey'] = fullKey;\n    return result;\n  }\n  /**\n   * @param {?} event\n   * @return {?}\n   */\n  static getEventFullKey(event) {\n    let /** @type {?} */fullKey = '';\n    let /** @type {?} */key = getDOM().getEventKey(event);\n    key = key.toLowerCase();\n    if (key === ' ') {\n      key = 'space'; // for readability\n    } else if (key === '.') {\n      key = 'dot'; // because '.' is used as a separator in event names\n    }\n\n    MODIFIER_KEYS.forEach(modifierName => {\n      if (modifierName != key) {\n        const /** @type {?} */modifierGetter = MODIFIER_KEY_GETTERS[modifierName];\n        if (modifierGetter(event)) {\n          fullKey += modifierName + '.';\n        }\n      }\n    });\n    fullKey += key;\n    return fullKey;\n  }\n  /**\n   * @param {?} fullKey\n   * @param {?} handler\n   * @param {?} zone\n   * @return {?}\n   */\n  static eventCallback(fullKey, handler, zone) {\n    return (event /** TODO #9100 */) => {\n      if (KeyEventsPlugin.getEventFullKey(event) === fullKey) {\n        zone.runGuarded(() => handler(event));\n      }\n    };\n  }\n  /**\n   * \\@internal\n   * @param {?} keyName\n   * @return {?}\n   */\n  static _normalizeKey(keyName) {\n    // TODO: switch to a Map if the mapping grows too much\n    switch (keyName) {\n      case 'esc':\n        return 'escape';\n      default:\n        return keyName;\n    }\n  }\n}\n\n/**\n * @nocollapse\n */\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * This helper class is used to get hold of an inert tree of DOM elements containing dirty HTML\n * that needs sanitizing.\n * Depending upon browser support we must use one of three strategies for doing this.\n * Support: Safari 10.x -> XHR strategy\n * Support: Firefox -> DomParser strategy\n * Default: InertDocument strategy\n */\nclass InertBodyHelper {\n  /**\n   * @param {?} defaultDoc\n   * @param {?} DOM\n   */\n  constructor(defaultDoc, DOM) {\n    this.defaultDoc = defaultDoc;\n    this.DOM = DOM;\n    const inertDocument = this.DOM.createHtmlDocument();\n    this.inertBodyElement = inertDocument.body;\n    if (this.inertBodyElement == null) {\n      // usually there should be only one body element in the document, but IE doesn't have any, so\n      // we need to create one.\n      const inertHtml = this.DOM.createElement('html', inertDocument);\n      this.inertBodyElement = this.DOM.createElement('body', inertDocument);\n      this.DOM.appendChild(inertHtml, this.inertBodyElement);\n      this.DOM.appendChild(inertDocument, inertHtml);\n    }\n    this.DOM.setInnerHTML(this.inertBodyElement, '<svg><g onload=\"this.parentNode.remove()\"></g></svg>');\n    if (this.inertBodyElement.querySelector && !this.inertBodyElement.querySelector('svg')) {\n      // We just hit the Safari 10.1 bug - which allows JS to run inside the SVG G element\n      // so use the XHR strategy.\n      this.getInertBodyElement = this.getInertBodyElement_XHR;\n      return;\n    }\n    this.DOM.setInnerHTML(this.inertBodyElement, '<svg><p><style><img src=\"</style><img src=x onerror=alert(1)//\">');\n    if (this.inertBodyElement.querySelector && this.inertBodyElement.querySelector('svg img')) {\n      // We just hit the Firefox bug - which prevents the inner img JS from being sanitized\n      // so use the DOMParser strategy, if it is available.\n      // If the DOMParser is not available then we are not in Firefox (Server/WebWorker?) so we\n      // fall through to the default strategy below.\n      if (isDOMParserAvailable()) {\n        this.getInertBodyElement = this.getInertBodyElement_DOMParser;\n        return;\n      }\n    }\n    // None of the bugs were hit so it is safe for us to use the default InertDocument strategy\n    this.getInertBodyElement = this.getInertBodyElement_InertDocument;\n  }\n  /**\n   * Use XHR to create and fill an inert body element (on Safari 10.1)\n   * See\n   * https://github.com/cure53/DOMPurify/blob/a992d3a75031cb8bb032e5ea8399ba972bdf9a65/src/purify.js#L439-L449\n   * @param {?} html\n   * @return {?}\n   */\n  getInertBodyElement_XHR(html) {\n    // We add these extra elements to ensure that the rest of the content is parsed as expected\n    // e.g. leading whitespace is maintained and tags like `<meta>` do not get hoisted to the\n    // `<head>` tag.\n    html = '<body><remove></remove>' + html + '</body>';\n    try {\n      html = encodeURI(html);\n    } catch (e) {\n      return null;\n    }\n    const /** @type {?} */xhr = new XMLHttpRequest();\n    xhr.responseType = 'document';\n    xhr.open('GET', 'data:text/html;charset=utf-8,' + html, false);\n    xhr.send(null);\n    const /** @type {?} */body = xhr.response.body;\n    body.removeChild( /** @type {?} */body.firstChild);\n    return body;\n  }\n  /**\n   * Use DOMParser to create and fill an inert body element (on Firefox)\n   * See https://github.com/cure53/DOMPurify/releases/tag/0.6.7\n   *\n   * @param {?} html\n   * @return {?}\n   */\n  getInertBodyElement_DOMParser(html) {\n    // We add these extra elements to ensure that the rest of the content is parsed as expected\n    // e.g. leading whitespace is maintained and tags like `<meta>` do not get hoisted to the\n    // `<head>` tag.\n    html = '<body><remove></remove>' + html + '</body>';\n    try {\n      const /** @type {?} */body = new window.DOMParser().parseFromString(html, 'text/html').body;\n      body.removeChild( /** @type {?} */body.firstChild);\n      return body;\n    } catch (e) {\n      return null;\n    }\n  }\n  /**\n   * Use an HTML5 `template` element, if supported, or an inert body element created via\n   * `createHtmlDocument` to create and fill an inert DOM element.\n   * This is the default sane strategy to use if the browser does not require one of the specialised\n   * strategies above.\n   * @param {?} html\n   * @return {?}\n   */\n  getInertBodyElement_InertDocument(html) {\n    // Prefer using <template> element if supported.\n    const /** @type {?} */templateEl = this.DOM.createElement('template');\n    if ('content' in templateEl) {\n      this.DOM.setInnerHTML(templateEl, html);\n      return templateEl;\n    }\n    this.DOM.setInnerHTML(this.inertBodyElement, html);\n    // Support: IE 9-11 only\n    // strip custom-namespaced attributes on IE<=11\n    if (this.defaultDoc.documentMode) {\n      this.stripCustomNsAttrs(this.inertBodyElement);\n    }\n    return this.inertBodyElement;\n  }\n  /**\n   * When IE9-11 comes across an unknown namespaced attribute e.g. 'xlink:foo' it adds 'xmlns:ns1'\n   * attribute to declare ns1 namespace and prefixes the attribute with 'ns1' (e.g.\n   * 'ns1:xlink:foo').\n   *\n   * This is undesirable since we don't want to allow any of these custom attributes. This method\n   * strips them all.\n   * @param {?} el\n   * @return {?}\n   */\n  stripCustomNsAttrs(el) {\n    this.DOM.attributeMap(el).forEach((_, attrName) => {\n      if (attrName === 'xmlns:ns1' || attrName.indexOf('ns1:') === 0) {\n        this.DOM.removeAttribute(el, attrName);\n      }\n    });\n    for (const /** @type {?} */n of this.DOM.childNodesAsList(el)) {\n      if (this.DOM.isElementNode(n)) this.stripCustomNsAttrs( /** @type {?} */n);\n    }\n  }\n}\n/**\n * We need to determine whether the DOMParser exists in the global context.\n * The try-catch is because, on some browsers, trying to access this property\n * on window can actually throw an error.\n *\n * @suppress {uselessCode}\n * @return {?}\n */\nfunction isDOMParserAvailable() {\n  try {\n    return !!window.DOMParser;\n  } catch (e) {\n    return false;\n  }\n}\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * A pattern that recognizes a commonly useful subset of URLs that are safe.\n *\n * This regular expression matches a subset of URLs that will not cause script\n * execution if used in URL context within a HTML document. Specifically, this\n * regular expression matches if (comment from here on and regex copied from\n * Soy's EscapingConventions):\n * (1) Either a protocol in a whitelist (http, https, mailto or ftp).\n * (2) or no protocol.  A protocol must be followed by a colon. The below\n *     allows that by allowing colons only after one of the characters [/?#].\n *     A colon after a hash (#) must be in the fragment.\n *     Otherwise, a colon after a (?) must be in a query.\n *     Otherwise, a colon after a single solidus (/) must be in a path.\n *     Otherwise, a colon after a double solidus (//) must be in the authority\n *     (before port).\n *\n * The pattern disallows &, used in HTML entity declarations before\n * one of the characters in [/?#]. This disallows HTML entities used in the\n * protocol name, which should never happen, e.g. \"h&#116;tp\" for \"http\".\n * It also disallows HTML entities in the first path part of a relative path,\n * e.g. \"foo&lt;bar/baz\".  Our existing escaping functions should not produce\n * that. More importantly, it disallows masking of a colon,\n * e.g. \"javascript&#58;...\".\n *\n * This regular expression was taken from the Closure sanitization library.\n */\nconst SAFE_URL_PATTERN = /^(?:(?:https?|mailto|ftp|tel|file):|[^&:/?#]*(?:[/?#]|$))/gi;\n/**\n * A pattern that matches safe data URLs. Only matches image, video and audio types.\n */\nconst DATA_URL_PATTERN = /^data:(?:image\\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\\/(?:mpeg|mp4|ogg|webm)|audio\\/(?:mp3|oga|ogg|opus));base64,[a-z0-9+\\/]+=*$/i;\n/**\n * @param {?} url\n * @return {?}\n */\nfunction sanitizeUrl(url) {\n  url = String(url);\n  if (url.match(SAFE_URL_PATTERN) || url.match(DATA_URL_PATTERN)) return url;\n  if (isDevMode()) {\n    getDOM().log(`WARNING: sanitizing unsafe URL value ${url} (see http://g.co/ng/security#xss)`);\n  }\n  return 'unsafe:' + url;\n}\n/**\n * @param {?} srcset\n * @return {?}\n */\nfunction sanitizeSrcset(srcset) {\n  srcset = String(srcset);\n  return srcset.split(',').map(srcset => sanitizeUrl(srcset.trim())).join(', ');\n}\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * @param {?} tags\n * @return {?}\n */\nfunction tagSet(tags) {\n  const /** @type {?} */res = {};\n  for (const /** @type {?} */t of tags.split(',')) res[t] = true;\n  return res;\n}\n/**\n * @param {...?} sets\n * @return {?}\n */\nfunction merge(...sets) {\n  const /** @type {?} */res = {};\n  for (const /** @type {?} */s of sets) {\n    for (const /** @type {?} */v in s) {\n      if (s.hasOwnProperty(v)) res[v] = true;\n    }\n  }\n  return res;\n}\n// Good source of info about elements and attributes\n// http://dev.w3.org/html5/spec/Overview.html#semantics\n// http://simon.html5.org/html-elements\n// Safe Void Elements - HTML5\n// http://dev.w3.org/html5/spec/Overview.html#void-elements\nconst VOID_ELEMENTS = tagSet('area,br,col,hr,img,wbr');\n// Elements that you can, intentionally, leave open (and which close themselves)\n// http://dev.w3.org/html5/spec/Overview.html#optional-tags\nconst OPTIONAL_END_TAG_BLOCK_ELEMENTS = tagSet('colgroup,dd,dt,li,p,tbody,td,tfoot,th,thead,tr');\nconst OPTIONAL_END_TAG_INLINE_ELEMENTS = tagSet('rp,rt');\nconst OPTIONAL_END_TAG_ELEMENTS = merge(OPTIONAL_END_TAG_INLINE_ELEMENTS, OPTIONAL_END_TAG_BLOCK_ELEMENTS);\n// Safe Block Elements - HTML5\nconst BLOCK_ELEMENTS = merge(OPTIONAL_END_TAG_BLOCK_ELEMENTS, tagSet('address,article,' + 'aside,blockquote,caption,center,del,details,dialog,dir,div,dl,figure,figcaption,footer,h1,h2,h3,h4,h5,' + 'h6,header,hgroup,hr,ins,main,map,menu,nav,ol,pre,section,summary,table,ul'));\n// Inline Elements - HTML5\nconst INLINE_ELEMENTS = merge(OPTIONAL_END_TAG_INLINE_ELEMENTS, tagSet('a,abbr,acronym,audio,b,' + 'bdi,bdo,big,br,cite,code,del,dfn,em,font,i,img,ins,kbd,label,map,mark,picture,q,ruby,rp,rt,s,' + 'samp,small,source,span,strike,strong,sub,sup,time,track,tt,u,var,video'));\nconst VALID_ELEMENTS = merge(VOID_ELEMENTS, BLOCK_ELEMENTS, INLINE_ELEMENTS, OPTIONAL_END_TAG_ELEMENTS);\n// Attributes that have href and hence need to be sanitized\nconst URI_ATTRS = tagSet('background,cite,href,itemtype,longdesc,poster,src,xlink:href');\n// Attributes that have special href set hence need to be sanitized\nconst SRCSET_ATTRS = tagSet('srcset');\nconst HTML_ATTRS = tagSet('abbr,accesskey,align,alt,autoplay,axis,bgcolor,border,cellpadding,cellspacing,class,clear,color,cols,colspan,' + 'compact,controls,coords,datetime,default,dir,download,face,headers,height,hidden,hreflang,hspace,' + 'ismap,itemscope,itemprop,kind,label,lang,language,loop,media,muted,nohref,nowrap,open,preload,rel,rev,role,rows,rowspan,rules,' + 'scope,scrolling,shape,size,sizes,span,srclang,start,summary,tabindex,target,title,translate,type,usemap,' + 'valign,value,vspace,width');\n// NB: This currently consciously doesn't support SVG. SVG sanitization has had several security\n// issues in the past, so it seems safer to leave it out if possible. If support for binding SVG via\n// innerHTML is required, SVG attributes should be added here.\n// NB: Sanitization does not allow <form> elements or other active elements (<button> etc). Those\n// can be sanitized, but they increase security surface area without a legitimate use case, so they\n// are left out here.\nconst VALID_ATTRS = merge(URI_ATTRS, SRCSET_ATTRS, HTML_ATTRS);\n/**\n * SanitizingHtmlSerializer serializes a DOM fragment, stripping out any unsafe elements and unsafe\n * attributes.\n */\nclass SanitizingHtmlSerializer {\n  constructor() {\n    this.sanitizedSomething = false;\n    this.buf = [];\n    this.DOM = getDOM();\n  }\n  /**\n   * @param {?} el\n   * @return {?}\n   */\n  sanitizeChildren(el) {\n    // This cannot use a TreeWalker, as it has to run on Angular's various DOM adapters.\n    // However this code never accesses properties off of `document` before deleting its contents\n    // again, so it shouldn't be vulnerable to DOM clobbering.\n    let /** @type {?} */current = this.DOM.firstChild(el);\n    while (current) {\n      if (this.DOM.isElementNode(current)) {\n        this.startElement( /** @type {?} */current);\n      } else if (this.DOM.isTextNode(current)) {\n        this.chars( /** @type {?} */this.DOM.nodeValue(current));\n      } else {\n        // Strip non-element, non-text nodes.\n        this.sanitizedSomething = true;\n      }\n      if (this.DOM.firstChild(current)) {\n        current = this.DOM.firstChild(current);\n        continue;\n      }\n      while (current) {\n        // Leaving the element. Walk up and to the right, closing tags as we go.\n        if (this.DOM.isElementNode(current)) {\n          this.endElement( /** @type {?} */current);\n        }\n        let /** @type {?} */next = this.checkClobberedElement(current, /** @type {?} */this.DOM.nextSibling(current));\n        if (next) {\n          current = next;\n          break;\n        }\n        current = this.checkClobberedElement(current, /** @type {?} */this.DOM.parentElement(current));\n      }\n    }\n    return this.buf.join('');\n  }\n  /**\n   * @param {?} element\n   * @return {?}\n   */\n  startElement(element) {\n    const /** @type {?} */tagName = this.DOM.nodeName(element).toLowerCase();\n    if (!VALID_ELEMENTS.hasOwnProperty(tagName)) {\n      this.sanitizedSomething = true;\n      return;\n    }\n    this.buf.push('<');\n    this.buf.push(tagName);\n    this.DOM.attributeMap(element).forEach((value, attrName) => {\n      const /** @type {?} */lower = attrName.toLowerCase();\n      if (!VALID_ATTRS.hasOwnProperty(lower)) {\n        this.sanitizedSomething = true;\n        return;\n      }\n      // TODO(martinprobst): Special case image URIs for data:image/...\n      if (URI_ATTRS[lower]) value = sanitizeUrl(value);\n      if (SRCSET_ATTRS[lower]) value = sanitizeSrcset(value);\n      this.buf.push(' ');\n      this.buf.push(attrName);\n      this.buf.push('=\"');\n      this.buf.push(encodeEntities(value));\n      this.buf.push('\"');\n    });\n    this.buf.push('>');\n  }\n  /**\n   * @param {?} current\n   * @return {?}\n   */\n  endElement(current) {\n    const /** @type {?} */tagName = this.DOM.nodeName(current).toLowerCase();\n    if (VALID_ELEMENTS.hasOwnProperty(tagName) && !VOID_ELEMENTS.hasOwnProperty(tagName)) {\n      this.buf.push('</');\n      this.buf.push(tagName);\n      this.buf.push('>');\n    }\n  }\n  /**\n   * @param {?} chars\n   * @return {?}\n   */\n  chars(chars) {\n    this.buf.push(encodeEntities(chars));\n  }\n  /**\n   * @param {?} node\n   * @param {?} nextNode\n   * @return {?}\n   */\n  checkClobberedElement(node, nextNode) {\n    if (nextNode && this.DOM.contains(node, nextNode)) {\n      throw new Error(`Failed to sanitize html because the element is clobbered: ${this.DOM.getOuterHTML(node)}`);\n    }\n    return nextNode;\n  }\n}\n// Regular Expressions for parsing tags and attributes\nconst SURROGATE_PAIR_REGEXP = /[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g;\n// ! to ~ is the ASCII range.\nconst NON_ALPHANUMERIC_REGEXP = /([^\\#-~ |!])/g;\n/**\n * Escapes all potentially dangerous characters, so that the\n * resulting string can be safely inserted into attribute or\n * element text.\n * @param {?} value\n * @return {?}\n */\nfunction encodeEntities(value) {\n  return value.replace(/&/g, '&amp;').replace(SURROGATE_PAIR_REGEXP, function (match) {\n    const /** @type {?} */hi = match.charCodeAt(0);\n    const /** @type {?} */low = match.charCodeAt(1);\n    return '&#' + ((hi - 0xD800) * 0x400 + (low - 0xDC00) + 0x10000) + ';';\n  }).replace(NON_ALPHANUMERIC_REGEXP, function (match) {\n    return '&#' + match.charCodeAt(0) + ';';\n  }).replace(/</g, '&lt;').replace(/>/g, '&gt;');\n}\nlet inertBodyHelper;\n/**\n * Sanitizes the given unsafe, untrusted HTML fragment, and returns HTML text that is safe to add to\n * the DOM in a browser environment.\n * @param {?} defaultDoc\n * @param {?} unsafeHtmlInput\n * @return {?}\n */\nfunction sanitizeHtml(defaultDoc, unsafeHtmlInput) {\n  const /** @type {?} */DOM = getDOM();\n  let /** @type {?} */inertBodyElement = null;\n  try {\n    inertBodyHelper = inertBodyHelper || new InertBodyHelper(defaultDoc, DOM);\n    // Make sure unsafeHtml is actually a string (TypeScript types are not enforced at runtime).\n    let /** @type {?} */unsafeHtml = unsafeHtmlInput ? String(unsafeHtmlInput) : '';\n    inertBodyElement = inertBodyHelper.getInertBodyElement(unsafeHtml);\n    // mXSS protection. Repeatedly parse the document to make sure it stabilizes, so that a browser\n    // trying to auto-correct incorrect HTML cannot cause formerly inert HTML to become dangerous.\n    let /** @type {?} */mXSSAttempts = 5;\n    let /** @type {?} */parsedHtml = unsafeHtml;\n    do {\n      if (mXSSAttempts === 0) {\n        throw new Error('Failed to sanitize html because the input is unstable');\n      }\n      mXSSAttempts--;\n      unsafeHtml = parsedHtml;\n      parsedHtml = DOM.getInnerHTML(inertBodyElement);\n      inertBodyElement = inertBodyHelper.getInertBodyElement(unsafeHtml);\n    } while (unsafeHtml !== parsedHtml);\n    const /** @type {?} */sanitizer = new SanitizingHtmlSerializer();\n    const /** @type {?} */safeHtml = sanitizer.sanitizeChildren(DOM.getTemplateContent(inertBodyElement) || inertBodyElement);\n    if (isDevMode() && sanitizer.sanitizedSomething) {\n      DOM.log('WARNING: sanitizing HTML stripped some content (see http://g.co/ng/security#xss).');\n    }\n    return safeHtml;\n  } finally {\n    // In case anything goes wrong, clear out inertElement to reset the entire DOM structure.\n    if (inertBodyElement) {\n      const /** @type {?} */parent = DOM.getTemplateContent(inertBodyElement) || inertBodyElement;\n      for (const /** @type {?} */child of DOM.childNodesAsList(parent)) {\n        DOM.removeChild(parent, child);\n      }\n    }\n  }\n}\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Regular expression for safe style values.\n *\n * Quotes (\" and ') are allowed, but a check must be done elsewhere to ensure they're balanced.\n *\n * ',' allows multiple values to be assigned to the same property (e.g. background-attachment or\n * font-family) and hence could allow multiple values to get injected, but that should pose no risk\n * of XSS.\n *\n * The function expression checks only for XSS safety, not for CSS validity.\n *\n * This regular expression was taken from the Closure sanitization library, and augmented for\n * transformation values.\n */\nconst VALUES = '[-,.\"\\'%_!# a-zA-Z0-9]+';\nconst TRANSFORMATION_FNS = '(?:matrix|translate|scale|rotate|skew|perspective)(?:X|Y|3d)?';\nconst COLOR_FNS = '(?:rgb|hsl)a?';\nconst GRADIENTS = '(?:repeating-)?(?:linear|radial)-gradient';\nconst CSS3_FNS = '(?:calc|attr)';\nconst FN_ARGS = '\\\\([-0-9.%, #a-zA-Z]+\\\\)';\nconst SAFE_STYLE_VALUE = new RegExp(`^(${VALUES}|` + `(?:${TRANSFORMATION_FNS}|${COLOR_FNS}|${GRADIENTS}|${CSS3_FNS})` + `${FN_ARGS})$`, 'g');\n/**\n * Matches a `url(...)` value with an arbitrary argument as long as it does\n * not contain parentheses.\n *\n * The URL value still needs to be sanitized separately.\n *\n * `url(...)` values are a very common use case, e.g. for `background-image`. With carefully crafted\n * CSS style rules, it is possible to construct an information leak with `url` values in CSS, e.g.\n * by observing whether scroll bars are displayed, or character ranges used by a font face\n * definition.\n *\n * Angular only allows binding CSS values (as opposed to entire CSS rules), so it is unlikely that\n * binding a URL value without further cooperation from the page will cause an information leak, and\n * if so, it is just a leak, not a full blown XSS vulnerability.\n *\n * Given the common use case, low likelihood of attack vector, and low impact of an attack, this\n * code is permissive and allows URLs that sanitize otherwise.\n */\nconst URL_RE = /^url\\(([^)]+)\\)$/;\n/**\n * Checks that quotes (\" and ') are properly balanced inside a string. Assumes\n * that neither escape (\\) nor any other character that could result in\n * breaking out of a string parsing context are allowed;\n * see http://www.w3.org/TR/css3-syntax/#string-token-diagram.\n *\n * This code was taken from the Closure sanitization library.\n * @param {?} value\n * @return {?}\n */\nfunction hasBalancedQuotes(value) {\n  let /** @type {?} */outsideSingle = true;\n  let /** @type {?} */outsideDouble = true;\n  for (let /** @type {?} */i = 0; i < value.length; i++) {\n    const /** @type {?} */c = value.charAt(i);\n    if (c === '\\'' && outsideDouble) {\n      outsideSingle = !outsideSingle;\n    } else if (c === '\"' && outsideSingle) {\n      outsideDouble = !outsideDouble;\n    }\n  }\n  return outsideSingle && outsideDouble;\n}\n/**\n * Sanitizes the given untrusted CSS style property value (i.e. not an entire object, just a single\n * value) and returns a value that is safe to use in a browser environment.\n * @param {?} value\n * @return {?}\n */\nfunction sanitizeStyle(value) {\n  value = String(value).trim(); // Make sure it's actually a string.\n  if (!value) return '';\n  // Single url(...) values are supported, but only for URLs that sanitize cleanly. See above for\n  // reasoning behind this.\n  const /** @type {?} */urlMatch = value.match(URL_RE);\n  if (urlMatch && sanitizeUrl(urlMatch[1]) === urlMatch[1] || value.match(SAFE_STYLE_VALUE) && hasBalancedQuotes(value)) {\n    return value; // Safe style values.\n  }\n\n  if (isDevMode()) {\n    getDOM().log(`WARNING: sanitizing unsafe style value ${value} (see http://g.co/ng/security#xss).`);\n  }\n  return 'unsafe';\n}\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * DomSanitizer helps preventing Cross Site Scripting Security bugs (XSS) by sanitizing\n * values to be safe to use in the different DOM contexts.\n *\n * For example, when binding a URL in an `<a [href]=\"someValue\">` hyperlink, `someValue` will be\n * sanitized so that an attacker cannot inject e.g. a `javascript:` URL that would execute code on\n * the website.\n *\n * In specific situations, it might be necessary to disable sanitization, for example if the\n * application genuinely needs to produce a `javascript:` style link with a dynamic value in it.\n * Users can bypass security by constructing a value with one of the `bypassSecurityTrust...`\n * methods, and then binding to that value from the template.\n *\n * These situations should be very rare, and extraordinary care must be taken to avoid creating a\n * Cross Site Scripting (XSS) security bug!\n *\n * When using `bypassSecurityTrust...`, make sure to call the method as early as possible and as\n * close as possible to the source of the value, to make it easy to verify no security bug is\n * created by its use.\n *\n * It is not required (and not recommended) to bypass security if the value is safe, e.g. a URL that\n * does not start with a suspicious protocol, or an HTML snippet that does not contain dangerous\n * code. The sanitizer leaves safe values intact.\n *\n * \\@security Calling any of the `bypassSecurityTrust...` APIs disables Angular's built-in\n * sanitization for the value passed in. Carefully check and audit all values and code paths going\n * into this call. Make sure any user data is appropriately escaped for this security context.\n * For more detail, see the [Security Guide](http://g.co/ng/security).\n *\n * \\@stable\n * @abstract\n */\nclass DomSanitizer {\n  /**\n   * Sanitizes a value for use in the given SecurityContext.\n   *\n   * If value is trusted for the context, this method will unwrap the contained safe value and use\n   * it directly. Otherwise, value will be sanitized to be safe in the given context, for example\n   * by replacing URLs that have an unsafe protocol part (such as `javascript:`). The implementation\n   * is responsible to make sure that the value can definitely be safely used in the given context.\n   * @abstract\n   * @param {?} context\n   * @param {?} value\n   * @return {?}\n   */\n  sanitize(context, value) {}\n  /**\n   * Bypass security and trust the given value to be safe HTML. Only use this when the bound HTML\n   * is unsafe (e.g. contains `<script>` tags) and the code should be executed. The sanitizer will\n   * leave safe HTML intact, so in most situations this method should not be used.\n   *\n   * **WARNING:** calling this method with untrusted user data exposes your application to XSS\n   * security risks!\n   * @abstract\n   * @param {?} value\n   * @return {?}\n   */\n  bypassSecurityTrustHtml(value) {}\n  /**\n   * Bypass security and trust the given value to be safe style value (CSS).\n   *\n   * **WARNING:** calling this method with untrusted user data exposes your application to XSS\n   * security risks!\n   * @abstract\n   * @param {?} value\n   * @return {?}\n   */\n  bypassSecurityTrustStyle(value) {}\n  /**\n   * Bypass security and trust the given value to be safe JavaScript.\n   *\n   * **WARNING:** calling this method with untrusted user data exposes your application to XSS\n   * security risks!\n   * @abstract\n   * @param {?} value\n   * @return {?}\n   */\n  bypassSecurityTrustScript(value) {}\n  /**\n   * Bypass security and trust the given value to be a safe style URL, i.e. a value that can be used\n   * in hyperlinks or `<img src>`.\n   *\n   * **WARNING:** calling this method with untrusted user data exposes your application to XSS\n   * security risks!\n   * @abstract\n   * @param {?} value\n   * @return {?}\n   */\n  bypassSecurityTrustUrl(value) {}\n  /**\n   * Bypass security and trust the given value to be a safe resource URL, i.e. a location that may\n   * be used to load executable code from, like `<script src>`, or `<iframe src>`.\n   *\n   * **WARNING:** calling this method with untrusted user data exposes your application to XSS\n   * security risks!\n   * @abstract\n   * @param {?} value\n   * @return {?}\n   */\n  bypassSecurityTrustResourceUrl(value) {}\n}\nclass DomSanitizerImpl extends DomSanitizer {\n  /**\n   * @param {?} _doc\n   */\n  constructor(_doc) {\n    super();\n    this._doc = _doc;\n  }\n  /**\n   * @param {?} ctx\n   * @param {?} value\n   * @return {?}\n   */\n  sanitize(ctx, value) {\n    if (value == null) return null;\n    switch (ctx) {\n      case SecurityContext.NONE:\n        return value;\n      case SecurityContext.HTML:\n        if (value instanceof SafeHtmlImpl) return value.changingThisBreaksApplicationSecurity;\n        this.checkNotSafeValue(value, 'HTML');\n        return sanitizeHtml(this._doc, String(value));\n      case SecurityContext.STYLE:\n        if (value instanceof SafeStyleImpl) return value.changingThisBreaksApplicationSecurity;\n        this.checkNotSafeValue(value, 'Style');\n        return sanitizeStyle( /** @type {?} */value);\n      case SecurityContext.SCRIPT:\n        if (value instanceof SafeScriptImpl) return value.changingThisBreaksApplicationSecurity;\n        this.checkNotSafeValue(value, 'Script');\n        throw new Error('unsafe value used in a script context');\n      case SecurityContext.URL:\n        if (value instanceof SafeResourceUrlImpl || value instanceof SafeUrlImpl) {\n          // Allow resource URLs in URL contexts, they are strictly more trusted.\n          return value.changingThisBreaksApplicationSecurity;\n        }\n        this.checkNotSafeValue(value, 'URL');\n        return sanitizeUrl(String(value));\n      case SecurityContext.RESOURCE_URL:\n        if (value instanceof SafeResourceUrlImpl) {\n          return value.changingThisBreaksApplicationSecurity;\n        }\n        this.checkNotSafeValue(value, 'ResourceURL');\n        throw new Error('unsafe value used in a resource URL context (see http://g.co/ng/security#xss)');\n      default:\n        throw new Error(`Unexpected SecurityContext ${ctx} (see http://g.co/ng/security#xss)`);\n    }\n  }\n  /**\n   * @param {?} value\n   * @param {?} expectedType\n   * @return {?}\n   */\n  checkNotSafeValue(value, expectedType) {\n    if (value instanceof SafeValueImpl) {\n      throw new Error(`Required a safe ${expectedType}, got a ${value.getTypeName()} ` + `(see http://g.co/ng/security#xss)`);\n    }\n  }\n  /**\n   * @param {?} value\n   * @return {?}\n   */\n  bypassSecurityTrustHtml(value) {\n    return new SafeHtmlImpl(value);\n  }\n  /**\n   * @param {?} value\n   * @return {?}\n   */\n  bypassSecurityTrustStyle(value) {\n    return new SafeStyleImpl(value);\n  }\n  /**\n   * @param {?} value\n   * @return {?}\n   */\n  bypassSecurityTrustScript(value) {\n    return new SafeScriptImpl(value);\n  }\n  /**\n   * @param {?} value\n   * @return {?}\n   */\n  bypassSecurityTrustUrl(value) {\n    return new SafeUrlImpl(value);\n  }\n  /**\n   * @param {?} value\n   * @return {?}\n   */\n  bypassSecurityTrustResourceUrl(value) {\n    return new SafeResourceUrlImpl(value);\n  }\n}\n\n/**\n * @nocollapse\n */\n\n/**\n * @abstract\n */\nclass SafeValueImpl {\n  /**\n   * @param {?} changingThisBreaksApplicationSecurity\n   */\n  constructor(changingThisBreaksApplicationSecurity) {\n    this.changingThisBreaksApplicationSecurity = changingThisBreaksApplicationSecurity;\n    // empty\n  }\n  /**\n   * @abstract\n   * @return {?}\n   */\n  getTypeName() {}\n  /**\n   * @return {?}\n   */\n  toString() {\n    return `SafeValue must use [property]=binding: ${this.changingThisBreaksApplicationSecurity}` + ` (see http://g.co/ng/security#xss)`;\n  }\n}\nclass SafeHtmlImpl extends SafeValueImpl {\n  /**\n   * @return {?}\n   */\n  getTypeName() {\n    return 'HTML';\n  }\n}\nclass SafeStyleImpl extends SafeValueImpl {\n  /**\n   * @return {?}\n   */\n  getTypeName() {\n    return 'Style';\n  }\n}\nclass SafeScriptImpl extends SafeValueImpl {\n  /**\n   * @return {?}\n   */\n  getTypeName() {\n    return 'Script';\n  }\n}\nclass SafeUrlImpl extends SafeValueImpl {\n  /**\n   * @return {?}\n   */\n  getTypeName() {\n    return 'URL';\n  }\n}\nclass SafeResourceUrlImpl extends SafeValueImpl {\n  /**\n   * @return {?}\n   */\n  getTypeName() {\n    return 'ResourceURL';\n  }\n}\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nconst INTERNAL_BROWSER_PLATFORM_PROVIDERS = [{\n  provide: PLATFORM_ID,\n  useValue: ɵPLATFORM_BROWSER_ID\n}, {\n  provide: PLATFORM_INITIALIZER,\n  useValue: initDomAdapter,\n  multi: true\n}, {\n  provide: PlatformLocation,\n  useClass: BrowserPlatformLocation\n}, {\n  provide: DOCUMENT$1,\n  useFactory: _document,\n  deps: []\n}];\n/**\n * \\@security Replacing built-in sanitization providers exposes the application to XSS risks.\n * Attacker-controlled data introduced by an unsanitized provider could expose your\n * application to XSS risks. For more detail, see the [Security Guide](http://g.co/ng/security).\n * \\@experimental\n */\nconst BROWSER_SANITIZATION_PROVIDERS = [{\n  provide: Sanitizer,\n  useExisting: DomSanitizer\n}, {\n  provide: DomSanitizer,\n  useClass: DomSanitizerImpl\n}];\n/**\n * \\@stable\n */\nconst platformBrowser = createPlatformFactory(platformCore, 'browser', INTERNAL_BROWSER_PLATFORM_PROVIDERS);\n/**\n * @return {?}\n */\nfunction initDomAdapter() {\n  BrowserDomAdapter.makeCurrent();\n  BrowserGetTestability.init();\n}\n/**\n * @return {?}\n */\nfunction errorHandler() {\n  return new ErrorHandler();\n}\n/**\n * @return {?}\n */\nfunction _document() {\n  return document;\n}\n/**\n * The ng module for the browser.\n *\n * \\@stable\n */\nclass BrowserModule {\n  /**\n   * @param {?} parentModule\n   */\n  constructor(parentModule) {\n    if (parentModule) {\n      throw new Error(`BrowserModule has already been loaded. If you need access to common directives such as NgIf and NgFor from a lazy loaded module, import CommonModule instead.`);\n    }\n  }\n  /**\n   * Configures a browser-based application to transition from a server-rendered app, if\n   * one is present on the page. The specified parameters must include an application id,\n   * which must match between the client and server applications.\n   *\n   * \\@experimental\n   * @param {?} params\n   * @return {?}\n   */\n  static withServerTransition(params) {\n    return {\n      ngModule: BrowserModule,\n      providers: [{\n        provide: APP_ID,\n        useValue: params.appId\n      }, {\n        provide: TRANSITION_ID,\n        useExisting: APP_ID\n      }, SERVER_TRANSITION_PROVIDERS]\n    };\n  }\n}\n\n/**\n * @nocollapse\n */\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nconst win = typeof window !== 'undefined' && window || {};\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nclass ChangeDetectionPerfRecord {\n  /**\n   * @param {?} msPerTick\n   * @param {?} numTicks\n   */\n  constructor(msPerTick, numTicks) {\n    this.msPerTick = msPerTick;\n    this.numTicks = numTicks;\n  }\n}\n/**\n * Entry point for all Angular profiling-related debug tools. This object\n * corresponds to the `ng.profiler` in the dev console.\n */\nclass AngularProfiler {\n  /**\n   * @param {?} ref\n   */\n  constructor(ref) {\n    this.appRef = ref.injector.get(ApplicationRef);\n  }\n  /**\n   * Exercises change detection in a loop and then prints the average amount of\n   * time in milliseconds how long a single round of change detection takes for\n   * the current state of the UI. It runs a minimum of 5 rounds for a minimum\n   * of 500 milliseconds.\n   *\n   * Optionally, a user may pass a `config` parameter containing a map of\n   * options. Supported options are:\n   *\n   * `record` (boolean) - causes the profiler to record a CPU profile while\n   * it exercises the change detector. Example:\n   *\n   * ```\n   * ng.profiler.timeChangeDetection({record: true})\n   * ```\n   * @param {?} config\n   * @return {?}\n   */\n  timeChangeDetection(config) {\n    const /** @type {?} */record = config && config['record'];\n    const /** @type {?} */profileName = 'Change Detection';\n    // Profiler is not available in Android browsers, nor in IE 9 without dev tools opened\n    const /** @type {?} */isProfilerAvailable = win.console.profile != null;\n    if (record && isProfilerAvailable) {\n      win.console.profile(profileName);\n    }\n    const /** @type {?} */start = getDOM().performanceNow();\n    let /** @type {?} */numTicks = 0;\n    while (numTicks < 5 || getDOM().performanceNow() - start < 500) {\n      this.appRef.tick();\n      numTicks++;\n    }\n    const /** @type {?} */end = getDOM().performanceNow();\n    if (record && isProfilerAvailable) {\n      // need to cast to <any> because type checker thinks there's no argument\n      // while in fact there is:\n      //\n      // https://developer.mozilla.org/en-US/docs/Web/API/Console/profileEnd\n      win.console.profileEnd(profileName);\n    }\n    const /** @type {?} */msPerTick = (end - start) / numTicks;\n    win.console.log(`ran ${numTicks} change detection cycles`);\n    win.console.log(`${msPerTick.toFixed(2)} ms per check`);\n    return new ChangeDetectionPerfRecord(msPerTick, numTicks);\n  }\n}\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nconst PROFILER_GLOBAL_NAME = 'profiler';\n/**\n * Enabled Angular debug tools that are accessible via your browser's\n * developer console.\n *\n * Usage:\n *\n * 1. Open developer console (e.g. in Chrome Ctrl + Shift + j)\n * 1. Type `ng.` (usually the console will show auto-complete suggestion)\n * 1. Try the change detection profiler `ng.profiler.timeChangeDetection()`\n *    then hit Enter.\n *\n * \\@experimental All debugging apis are currently experimental.\n * @template T\n * @param {?} ref\n * @return {?}\n */\nfunction enableDebugTools(ref) {\n  exportNgVar(PROFILER_GLOBAL_NAME, new AngularProfiler(ref));\n  return ref;\n}\n/**\n * Disables Angular tools.\n *\n * \\@experimental All debugging apis are currently experimental.\n * @return {?}\n */\nfunction disableDebugTools() {\n  exportNgVar(PROFILER_GLOBAL_NAME, null);\n}\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Predicates for use with {\\@link DebugElement}'s query functions.\n *\n * \\@experimental All debugging apis are currently experimental.\n */\nclass By {\n  /**\n   * Match all elements.\n   *\n   * ## Example\n   *\n   * {\\@example platform-browser/dom/debug/ts/by/by.ts region='by_all'}\n   * @return {?}\n   */\n  static all() {\n    return debugElement => true;\n  }\n  /**\n   * Match elements by the given CSS selector.\n   *\n   * ## Example\n   *\n   * {\\@example platform-browser/dom/debug/ts/by/by.ts region='by_css'}\n   * @param {?} selector\n   * @return {?}\n   */\n  static css(selector) {\n    return debugElement => {\n      return debugElement.nativeElement != null ? getDOM().elementMatches(debugElement.nativeElement, selector) : false;\n    };\n  }\n  /**\n   * Match elements that have the given directive present.\n   *\n   * ## Example\n   *\n   * {\\@example platform-browser/dom/debug/ts/by/by.ts region='by_directive'}\n   * @param {?} type\n   * @return {?}\n   */\n  static directive(type) {\n    return debugElement => debugElement.providerTokens.indexOf(type) !== -1;\n  }\n}\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * @module\n * @description\n * Entry point for all public APIs of the common package.\n */\n/**\n * \\@stable\n */\nconst VERSION = new Version('4.4.7');\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * @module\n * @description\n * Entry point for all public APIs of the platform-browser package.\n */\n\n// This file only reexports content of the `src` folder. Keep it that way.\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { BrowserModule, platformBrowser, Meta, Title, disableDebugTools, enableDebugTools, By, NgProbeToken$1 as NgProbeToken, DOCUMENT$1 as DOCUMENT, EVENT_MANAGER_PLUGINS, EventManager, HAMMER_GESTURE_CONFIG, HammerGestureConfig, DomSanitizer, VERSION, BROWSER_SANITIZATION_PROVIDERS as ɵBROWSER_SANITIZATION_PROVIDERS, INTERNAL_BROWSER_PLATFORM_PROVIDERS as ɵINTERNAL_BROWSER_PLATFORM_PROVIDERS, initDomAdapter as ɵinitDomAdapter, BrowserDomAdapter as ɵBrowserDomAdapter, BrowserPlatformLocation as ɵBrowserPlatformLocation, TRANSITION_ID as ɵTRANSITION_ID, BrowserGetTestability as ɵBrowserGetTestability, ELEMENT_PROBE_PROVIDERS as ɵELEMENT_PROBE_PROVIDERS, DomAdapter as ɵDomAdapter, getDOM as ɵgetDOM, setRootDomAdapter as ɵsetRootDomAdapter, DomRendererFactory2 as ɵDomRendererFactory2, NAMESPACE_URIS as ɵNAMESPACE_URIS, flattenStyles as ɵflattenStyles, shimContentAttribute as ɵshimContentAttribute, shimHostAttribute as ɵshimHostAttribute, DomEventsPlugin as ɵDomEventsPlugin, HammerGesturesPlugin as ɵHammerGesturesPlugin, KeyEventsPlugin as ɵKeyEventsPlugin, DomSharedStylesHost as ɵDomSharedStylesHost, SharedStylesHost as ɵSharedStylesHost, _document as ɵb, errorHandler as ɵa, GenericBrowserDomAdapter as ɵh, SERVER_TRANSITION_PROVIDERS as ɵg, appInitializerFactory as ɵf, _createNgProbe as ɵc, EventManagerPlugin as ɵd, DomSanitizerImpl as ɵe };\n//# sourceMappingURL=platform-browser.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}