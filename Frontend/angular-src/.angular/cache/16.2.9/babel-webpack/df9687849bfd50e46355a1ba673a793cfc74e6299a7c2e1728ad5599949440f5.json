{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function (d, b) {\n  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n  function __() {\n    this.constructor = d;\n  }\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subject_1 = require('../Subject');\nvar Observable_1 = require('../Observable');\nvar Subscriber_1 = require('../Subscriber');\nvar Subscription_1 = require('../Subscription');\nvar refCount_1 = require('../operators/refCount');\n/**\n * @class ConnectableObservable<T>\n */\nvar ConnectableObservable = function (_super) {\n  __extends(ConnectableObservable, _super);\n  function ConnectableObservable( /** @deprecated internal use only */source, /** @deprecated internal use only */subjectFactory) {\n    _super.call(this);\n    this.source = source;\n    this.subjectFactory = subjectFactory;\n    /** @deprecated internal use only */\n    this._refCount = 0;\n    this._isComplete = false;\n  }\n  /** @deprecated internal use only */\n  ConnectableObservable.prototype._subscribe = function (subscriber) {\n    return this.getSubject().subscribe(subscriber);\n  };\n  /** @deprecated internal use only */\n  ConnectableObservable.prototype.getSubject = function () {\n    var subject = this._subject;\n    if (!subject || subject.isStopped) {\n      this._subject = this.subjectFactory();\n    }\n    return this._subject;\n  };\n  ConnectableObservable.prototype.connect = function () {\n    var connection = this._connection;\n    if (!connection) {\n      this._isComplete = false;\n      connection = this._connection = new Subscription_1.Subscription();\n      connection.add(this.source.subscribe(new ConnectableSubscriber(this.getSubject(), this)));\n      if (connection.closed) {\n        this._connection = null;\n        connection = Subscription_1.Subscription.EMPTY;\n      } else {\n        this._connection = connection;\n      }\n    }\n    return connection;\n  };\n  ConnectableObservable.prototype.refCount = function () {\n    return refCount_1.refCount()(this);\n  };\n  return ConnectableObservable;\n}(Observable_1.Observable);\nexports.ConnectableObservable = ConnectableObservable;\nvar connectableProto = ConnectableObservable.prototype;\nexports.connectableObservableDescriptor = {\n  operator: {\n    value: null\n  },\n  _refCount: {\n    value: 0,\n    writable: true\n  },\n  _subject: {\n    value: null,\n    writable: true\n  },\n  _connection: {\n    value: null,\n    writable: true\n  },\n  _subscribe: {\n    value: connectableProto._subscribe\n  },\n  _isComplete: {\n    value: connectableProto._isComplete,\n    writable: true\n  },\n  getSubject: {\n    value: connectableProto.getSubject\n  },\n  connect: {\n    value: connectableProto.connect\n  },\n  refCount: {\n    value: connectableProto.refCount\n  }\n};\nvar ConnectableSubscriber = function (_super) {\n  __extends(ConnectableSubscriber, _super);\n  function ConnectableSubscriber(destination, connectable) {\n    _super.call(this, destination);\n    this.connectable = connectable;\n  }\n  ConnectableSubscriber.prototype._error = function (err) {\n    this._unsubscribe();\n    _super.prototype._error.call(this, err);\n  };\n  ConnectableSubscriber.prototype._complete = function () {\n    this.connectable._isComplete = true;\n    this._unsubscribe();\n    _super.prototype._complete.call(this);\n  };\n  /** @deprecated internal use only */\n  ConnectableSubscriber.prototype._unsubscribe = function () {\n    var connectable = this.connectable;\n    if (connectable) {\n      this.connectable = null;\n      var connection = connectable._connection;\n      connectable._refCount = 0;\n      connectable._subject = null;\n      connectable._connection = null;\n      if (connection) {\n        connection.unsubscribe();\n      }\n    }\n  };\n  return ConnectableSubscriber;\n}(Subject_1.SubjectSubscriber);\nvar RefCountOperator = function () {\n  function RefCountOperator(connectable) {\n    this.connectable = connectable;\n  }\n  RefCountOperator.prototype.call = function (subscriber, source) {\n    var connectable = this.connectable;\n    connectable._refCount++;\n    var refCounter = new RefCountSubscriber(subscriber, connectable);\n    var subscription = source.subscribe(refCounter);\n    if (!refCounter.closed) {\n      refCounter.connection = connectable.connect();\n    }\n    return subscription;\n  };\n  return RefCountOperator;\n}();\nvar RefCountSubscriber = function (_super) {\n  __extends(RefCountSubscriber, _super);\n  function RefCountSubscriber(destination, connectable) {\n    _super.call(this, destination);\n    this.connectable = connectable;\n  }\n  /** @deprecated internal use only */\n  RefCountSubscriber.prototype._unsubscribe = function () {\n    var connectable = this.connectable;\n    if (!connectable) {\n      this.connection = null;\n      return;\n    }\n    this.connectable = null;\n    var refCount = connectable._refCount;\n    if (refCount <= 0) {\n      this.connection = null;\n      return;\n    }\n    connectable._refCount = refCount - 1;\n    if (refCount > 1) {\n      this.connection = null;\n      return;\n    }\n    ///\n    // Compare the local RefCountSubscriber's connection Subscription to the\n    // connection Subscription on the shared ConnectableObservable. In cases\n    // where the ConnectableObservable source synchronously emits values, and\n    // the RefCountSubscriber's downstream Observers synchronously unsubscribe,\n    // execution continues to here before the RefCountOperator has a chance to\n    // supply the RefCountSubscriber with the shared connection Subscription.\n    // For example:\n    // ```\n    // Observable.range(0, 10)\n    //   .publish()\n    //   .refCount()\n    //   .take(5)\n    //   .subscribe();\n    // ```\n    // In order to account for this case, RefCountSubscriber should only dispose\n    // the ConnectableObservable's shared connection Subscription if the\n    // connection Subscription exists, *and* either:\n    //   a. RefCountSubscriber doesn't have a reference to the shared connection\n    //      Subscription yet, or,\n    //   b. RefCountSubscriber's connection Subscription reference is identical\n    //      to the shared connection Subscription\n    ///\n    var connection = this.connection;\n    var sharedConnection = connectable._connection;\n    this.connection = null;\n    if (sharedConnection && (!connection || sharedConnection === connection)) {\n      sharedConnection.unsubscribe();\n    }\n  };\n  return RefCountSubscriber;\n}(Subscriber_1.Subscriber);\n//# sourceMappingURL=ConnectableObservable.js.map","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}